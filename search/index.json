[{"content":"è¾“å…¥æè¿° è¾“å…¥ä¸€è¡Œï¼Œä»£è¡¨è¦è®¡ç®—çš„å­—ç¬¦ä¸²ï¼Œéç©ºï¼Œé•¿åº¦å°äº5000ã€‚\nè¾“å‡ºæè¿° è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºè¾“å…¥å­—ç¬¦ä¸²æœ€åä¸€ä¸ªå•è¯çš„é•¿åº¦ã€‚\nç¤ºä¾‹ è¾“å…¥ hello world\nè¾“å‡º 5\nè¯´æ˜ æœ€åä¸€ä¸ªå•è¯ä¸ºworldï¼Œé•¿åº¦ä¸º5\ncode go Copy package easy import \u0026#34;strings\u0026#34; func HJ1(str string) int { arr := strings.Split(str, \u0026#34; \u0026#34;) return len(arr[len(arr)-1]) } 1 2 3 4 5 6 7 8 package easy import \u0026#34;strings\u0026#34; func HJ1(str string) int { arr := strings.Split(str, \u0026#34; \u0026#34;) return len(arr[len(arr)-1]) } ","date":"2023-01-17T00:00:00Z","permalink":"https://superlitian.github.io/p/hj1/","title":"HJ1 å­—ç¬¦ä¸²æœ€åä¸€ä¸ªå•è¯çš„é•¿åº¦"},{"content":"æ•°æ®èŒƒå›´ 1â‰¤nâ‰¤1000\nè¾“å…¥æè¿° ç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªç”±å­—æ¯ã€æ•°å­—å’Œç©ºæ ¼ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œç¬¬äºŒè¡Œè¾“å…¥ä¸€ä¸ªå­—ç¬¦ï¼ˆä¿è¯è¯¥å­—ç¬¦ä¸ä¸ºç©ºæ ¼ï¼‰ã€‚\nè¾“å‡ºæè¿° è¾“å‡ºè¾“å…¥å­—ç¬¦ä¸²ä¸­å«æœ‰è¯¥å­—ç¬¦çš„ä¸ªæ•°ã€‚ï¼ˆä¸åŒºåˆ†å¤§å°å†™å­—æ¯ï¼‰\nç¤ºä¾‹ è¾“å…¥ ABCabc A\nè¾“å‡º 2\ncode go Copy package easy import \u0026#34;strings\u0026#34; func HJ2(str, target string) int { s := strings.ToLower(str) tar := strings.ToLower(target) count := 0 for _, v := range s { if string(v) == tar { count\u0026#43;\u0026#43; } } return count } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package easy import \u0026#34;strings\u0026#34; func HJ2(str, target string) int { s := strings.ToLower(str) tar := strings.ToLower(target) count := 0 for _, v := range s { if string(v) == tar { count++ } } return count } ","date":"2023-01-17T00:00:00Z","permalink":"https://superlitian.github.io/p/hj2/","title":"HJ2 è®¡ç®—æŸå­—ç¬¦å‡ºç°æ¬¡æ•°"},{"content":"è¾“å…¥æè¿° è¿ç»­è¾“å…¥å­—ç¬¦ä¸²(æ¯ä¸ªå­—ç¬¦ä¸²é•¿åº¦å°äºç­‰äº100)\nè¾“å‡ºæè¿° ä¾æ¬¡è¾“å‡ºæ‰€æœ‰åˆ†å‰²åçš„é•¿åº¦ä¸º8çš„æ–°å­—ç¬¦ä¸²\nç¤ºä¾‹ è¾“å…¥ abc\nè¾“å‡º abc00000\ncode go Copy package easy import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; \u0026#34;strings\u0026#34; ) func HJ4(str string) string { if str == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34; } var build strings.Builder length := int(math.Ceil(float64(len(str)) / 8.0)) arr := make([]string, length) // len(str) \u0026lt;= 8 if len(str) \u0026lt;= 8 { n := 8 - len(str) build.WriteString(str) for n \u0026gt; 0 { build.WriteString(\u0026#34;0\u0026#34;) n-- } return build.String() } p1 := 0 index := 0 p2 := 7 for p1 \u0026lt; len(str) { build.WriteString(string(str[p1])) if p1 == p2 { arr[index] = build.String() build.Reset() index\u0026#43;\u0026#43; p2 = p1 \u0026#43; 8 } p1\u0026#43;\u0026#43; } if p1 \u0026lt; p2 { c := p2 - p1 for c \u0026gt;= 0 { build.WriteString(\u0026#34;0\u0026#34;) c-- } arr[index] = build.String() } res := \u0026#34;\u0026#34; for _, v := range arr { res \u0026#43;= fmt.Sprintf(\u0026#34;%s\\n\u0026#34;, v) } fmt.Println(arr) return res } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package easy import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; \u0026#34;strings\u0026#34; ) func HJ4(str string) string { if str == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34; } var build strings.Builder length := int(math.Ceil(float64(len(str)) / 8.0)) arr := make([]string, length) // len(str) \u0026lt;= 8 if len(str) \u0026lt;= 8 { n := 8 - len(str) build.WriteString(str) for n \u0026gt; 0 { build.WriteString(\u0026#34;0\u0026#34;) n-- } return build.String() } p1 := 0 index := 0 p2 := 7 for p1 \u0026lt; len(str) { build.WriteString(string(str[p1])) if p1 == p2 { arr[index] = build.String() build.Reset() index++ p2 = p1 + 8 } p1++ } if p1 \u0026lt; p2 { c := p2 - p1 for c \u0026gt;= 0 { build.WriteString(\u0026#34;0\u0026#34;) c-- } arr[index] = build.String() } res := \u0026#34;\u0026#34; for _, v := range arr { res += fmt.Sprintf(\u0026#34;%s\\n\u0026#34;, v) } fmt.Println(arr) return res } ","date":"2023-01-17T00:00:00Z","permalink":"https://superlitian.github.io/p/hj4/","title":"HJ4 å­—ç¬¦ä¸²åˆ†éš”"},{"content":"æ•°æ®èŒƒå›´ $$ 1â‰¤nâ‰¤2^{31}âˆ’1 $$\nè¾“å…¥æè¿° è¾“å…¥ä¸€ä¸ªåå…­è¿›åˆ¶çš„æ•°å€¼å­—ç¬¦ä¸²ã€‚\nè¾“å‡ºæè¿° è¾“å‡ºè¯¥æ•°å€¼çš„åè¿›åˆ¶å­—ç¬¦ä¸²ã€‚ä¸åŒç»„çš„æµ‹è¯•ç”¨ä¾‹ç”¨\\néš”å¼€ã€‚\nç¤ºä¾‹ è¾“å…¥ 0e\nè¾“å‡º 14\nè¯´æ˜ æœ€åä¸€ä¸ªå•è¯ä¸ºnowcoderï¼Œé•¿åº¦ä¸º8\ncode go Copy package easy import ( \u0026#34;strconv\u0026#34; ) func HJ5(str string) int { res, err := strconv.ParseInt(str, 16, 32) if err != nil { panic(err) } return int(res) } 1 2 3 4 5 6 7 8 9 10 11 12 13 package easy import ( \u0026#34;strconv\u0026#34; ) func HJ5(str string) int { res, err := strconv.ParseInt(str, 16, 32) if err != nil { panic(err) } return int(res) } ","date":"2023-01-17T00:00:00Z","permalink":"https://superlitian.github.io/p/hj5/","title":"HJ5 è¿›åˆ¶è½¬æ¢"},{"content":"ğŸŒï¸ å®ç”¨çš„å·¥å…·ç±»ç½‘ç«™ æ‰€æœ‰ç½‘ç«™å…¨éƒ¨ä¸ºå…è´¹ï¼Œéƒ¨åˆ†ç½‘ç«™å¯èƒ½éœ€è¦ç¿»å¢™\nğŸ‡ºğŸ‡¸ removebg ä»‹ç»ï¼šåˆ é™¤å›¾åƒèƒŒæ™¯ å®˜ç½‘ï¼šhttps://www.remove.bg/zh ğŸ‡¨ğŸ‡³ å¤©ç©ºä¹‹åŸ ä»‹ç»ï¼šå…¨çƒèˆªæ‹çˆ±å¥½è€…å’Œä¸“ä¸šæ‘„å½±å¸ˆçš„ä½œå“ç¤¾åŒº å®˜ç½‘ï¼šhttps://www.skypixel.com/ ğŸ‡¨ğŸ‡³ å¹½çµç–¾æ­¥ ä»‹ç»ï¼šä¸“ä¸€çš„è‹±é›„è”ç›Ÿå†…å®¹èšåˆ å®˜ç½‘ï¼šhttps://www.ghostoact.com/ ğŸ‡©ğŸ‡ª CloudConvert ä»‹ç»ï¼šå›¾ç‰‡æ–‡ä»¶è½¬æ¢ï¼Œå¯ä»¥è½¬æ¢ä¸ºiconç­‰ å®˜ç½‘ï¼šhttps://cloudconvert.com/ ğŸ‡¨ğŸ‡³ m3ub downloader ä»‹ç»ï¼šm3u8 è§†é¢‘åœ¨çº¿æå–å·¥å…· å®˜ç½‘ï¼šhttp://blog.luckly-mjw.cn/tool-show/m3u8-downloader/index.html ğŸ‡ºğŸ‡¸ Zamzar ä»‹ç»ï¼šè§†é¢‘è½¬æ¢å™¨ã€éŸ³é¢‘è½¬æ¢å™¨ã€å›¾åƒè½¬æ¢å™¨ã€ç”µå­ä¹¦è½¬æ¢å™¨ å®˜ç½‘ï¼šhttps://www.zamzar.com/ ğŸ‡¨ğŸ‡³ CatNet ä»‹ç»ï¼šä»£ç†å¹³å° å®˜ç½‘ï¼šhttps://dash.catnet.uk/ ğŸ‡¨ğŸ‡³ EmojiALL ä»‹ç»ï¼šEmoji è¯å…¸ å®˜ç½‘ï¼šhttps://www.emojiall.com/ ","date":"2022-10-12T00:00:00Z","permalink":"https://superlitian.github.io/p/site/","title":"ğŸŒï¸ å®ç”¨çš„å·¥å…·ç±»ç½‘ç«™"},{"content":"ğŸŒ¼ å¼€æºä»£ç è´¡çŒ®æŒ‡å— ğŸŒ¿ Fork ä»£ç  è®¿é—®è‡ªå·±æƒ³è¦è´¡çŒ®çš„ä»£ç åº“ï¼Œç„¶åforkä»£ç åˆ°è‡ªå·±çš„ä»£ç ä»“åº“ã€‚ ğŸª Clone ä»£ç åˆ°æœ¬åœ° å‡è®¾forkå®Œä¹‹åçš„ä»£ç ä»“åº“è·¯å¾„ä¸º ğŸ”— git@github.com:uaanaa/xuperchain.git\nshell Copy git clone git@github.com:uaanaa/xuperchain.git 1 git clone git@github.com:uaanaa/xuperchain.git å…‹éš†åˆ°æœ¬åœ°ä¹‹åè®¾ç½®ä¸€ä¸ª upstream çš„ remote åœ°å€ï¼Œæ–¹ä¾¿æˆ‘ä»¬åŒæ­¥åŸå§‹ä»“åº“åœ°å€çš„æ›´æ–°\nshell Copy git remote add upstream https://github.com/xuperchain/xuperchain.git 1 git remote add upstream https://github.com/xuperchain/xuperchain.git â™ åŒæ­¥ä»£ç \u0026amp;å»ºç«‹åˆ†æ”¯ æ¯æ¬¡è¦æäº¤PRçš„æ—¶å€™éƒ½è¦ æ–°å»º ä¸€ä¸ªåˆ†æ”¯ï¼Œè¿™æ ·å¯ä»¥åŒæ—¶å¼€å‘å¤šä¸ªfeatureï¼Œåˆ†æ”¯åŸºäº upstream çš„ master å»ºç«‹\nshell Copy # æ‹‰å–ä¸Šæ¸¸çš„æœ€æ–°ä»£ç  git fetch upstream # å»ºç«‹æ–°åˆ†æ”¯ git checkout -b new_feature upstream/master 1 2 3 4 5 # æ‹‰å–ä¸Šæ¸¸çš„æœ€æ–°ä»£ç  git fetch upstream # å»ºç«‹æ–°åˆ†æ”¯ git checkout -b new_feature upstream/master ğŸŸ¢ æäº¤ä»£ç  å½“æˆ‘ä»¬çš„ä»£ç å†™å®Œä¹‹åå°±å¯ä»¥æäº¤äº†ï¼Œæ³¨æ„æˆ‘ä»¬è¿™é‡Œæäº¤çš„remoteæ˜¯ originï¼Œä¹Ÿå°±æ˜¯è‡ªå·±çš„ä»£ç ä»“åº“\nshell Copy git push origin new_feature Counting objects: 3, done. Delta compression using up to 2 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 286 bytes | 286.00 KiB/s, done. Total 3 (delta 2), reused 0 (delta 0) remote: Resolving deltas: 100% (2/2), completed with 2 local objects. remote: remote: Create a pull request for \u0026#39;new_feature\u0026#39; on GitHub by visiting: remote: https://github.com/uaanaa/xuperunion/pull/new/new_feature remote: To https://github.com/uaanaa/xuperunion.git * [new branch] new_feature -\u0026gt; new_feature 1 2 3 4 5 6 7 8 9 10 11 12 13 git push origin new_feature Counting objects: 3, done. Delta compression using up to 2 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 286 bytes | 286.00 KiB/s, done. Total 3 (delta 2), reused 0 (delta 0) remote: Resolving deltas: 100% (2/2), completed with 2 local objects. remote: remote: Create a pull request for \u0026#39;new_feature\u0026#39; on GitHub by visiting: remote: https://github.com/uaanaa/xuperunion/pull/new/new_feature remote: To https://github.com/uaanaa/xuperunion.git * [new branch] new_feature -\u0026gt; new_feature ğŸ‡¨ğŸ‡³ åˆ›å»ºPR æäº¤å®Œä¹‹åï¼Œä¸€èˆ¬æœ‰ä¸ªç±»ä¼¼ https://github.com/uaanaa/xuperunion/pull/new/new_feature è¿™æ ·çš„åœ°å€ï¼Œåœ¨æµè§ˆå™¨æ‰“å¼€è¿™ä¸ªåœ°å€å°±è·³è½¬åˆ°åˆ›å»ºPRçš„é¡µé¢è¿›è¡Œæäº¤å³å¯ã€‚\n","date":"2022-10-12T00:00:00Z","permalink":"https://superlitian.github.io/p/pr/","title":"ğŸ“ƒ å¼€æºä»£ç è´¡çŒ®æ–¹æ³•"},{"content":"ğŸ”´ git æ£€æŸ¥å¤§å°å†™ä¸æ•æ„Ÿ ä»Šå¤©éœ€è¦å°†é¡¹ç›®ä¸€ä¸ªæ–‡ä»¶åé¦–å­—æ¯ä»å°å†™æ”¹ä¸ºå¤§å†™ï¼Œæ”¹å¥½ä¹‹åå‘ç° git status å¹¶æ²¡æœ‰æ£€æŸ¥åˆ°æ›´æ”¹ã€‚\nğŸŸ¡ åŸå›  å¯¹äº windows å’Œ macOS ç”¨æˆ·ï¼Œæ¯æ¬¡ git clone ä¹‹åï¼Œéƒ½åœ¨è¯¥é¡¹ç›®çš„ ğŸ“ .git/config æ–‡ä»¶ä¸­è®¾ç½®äº† core.ignorecase = true\nğŸŸ¢ è§£å†³ åœ¨ç»ˆç«¯æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼Œå°†å¿½ç•¥å¤§å°å†™æ”¹ä¸ºfalse\nshell Copy git config core.ignorecase false 1 git config core.ignorecase false ","date":"2022-10-12T00:00:00Z","permalink":"https://superlitian.github.io/p/git/","title":"ğŸ§° git å¿½ç•¥å¤§å°å†™é—®é¢˜"},{"content":"ERC20 solidity Copy // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.0; contract Cafe20{ using SafeMath for uint256; // creator address private _creator; // token name string private _name; // token symbol string private _symbol; // token totalSupply uint256 private _totalSupply; // address have how much token mapping (address =\u0026gt; uint256) private balances; // owner approve spender spend how much token mapping (address =\u0026gt; mapping (address =\u0026gt; uint256)) private allowances; constructor(string memory name_, string memory symbol_) public { _creator = theSender(); _name = name_; _symbol = symbol_; } /** * total tokens */ function totalSupply() public view returns (uint256) { return _totalSupply; } /** * mints tokens, only creator can call this function */ function mint(uint256 value) public returns (bool) { require(theSender() == _creator, \u0026#34;Cafe20: No permission\u0026#34;); _totalSupply = _totalSupply.add(value); balances[_creator] = balances[_creator].add(value); return true; } // when the token transfer, must be call this function event Transfer(address indexed _from, address indexed _to, uint256 _value); // when the approval, must be call this function event Approval(address indexed _owner, address indexed _spender, uint256 _value); /** * return this token\u0026#39;s name */ function name() public view returns (string memory) { return _name; } function creator() public view returns (address) { return _creator; } /** * return this token\u0026#39;s symbol */ function symbol() public view returns (string memory) { return _symbol; } /** * return this token\u0026#39;s number of decimal places */ function decimals() public view virtual returns (uint8) { return 5; } /* * return the sender\u0026#39;s balance */ function balance() public view returns (uint256 balance) { return balances[theSender()]; } /** * return the balance of this address */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } /** * transfer to address */ function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[theSender()] \u0026gt;= _value,\u0026#34;Cafe20: not enough balance\u0026#34;); require(_to != address(0), \u0026#34;Cafe20: can not to the zero address transfer\u0026#34;); balances[theSender()] = balances[theSender()].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(theSender(), _to, _value); return true; } /** * transfer from address to other address */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { if(theSender() == _from){ return transfer(_to, _value); } uint256 tokens = allowance(_from, theSender()); require(_from != address(0), \u0026#34;Cafe20: can not from the zero address transfer\u0026#34;); require(_to != address(0), \u0026#34;Cafe20: can not to the zero address transfer\u0026#34;); require(balances[_from] \u0026gt;= _value, \u0026#34;Cafe20: not enough tokens\u0026#34;); require(tokens \u0026gt;= _value, \u0026#34;Cafe20: the allowance not enough tokens\u0026#34;); // update balance balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); // update allowances allowances[_from][theSender()] = allowances[_from][theSender()].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * approve the spender for msg.sender */ function approve(address _spender, uint256 _value) public returns (bool success) { address _owner = theSender(); require(_spender != address(0), \u0026#34;Cafe20: can not approve the zero address\u0026#34;); require(balances[_owner] \u0026gt;= _value, \u0026#34;Cafe20: not enough tokens\u0026#34;); allowances[_owner][_spender] = allowances[_owner][_spender].add(_value); emit Approval(_owner, _spender, _value); return true; } /* * query the amount which _spender is still allowed to withdraw from _owner */ function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowances[_owner][_spender]; } /* * destroy the tokens */ function destroyTokens(uint256 _value) public returns (bool success) { require(balances[theSender()] \u0026gt;= _value, \u0026#34;Cafe20: not enough tokens\u0026#34;); balances[theSender()] = balances[theSender()].sub(_value); _totalSupply = _totalSupply.sub(_value); return true; } /* * msg.sender */ function theSender() private view returns (address) { return msg.sender; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring \u0026#39;a\u0026#39; not being zero, but the // benefit is lost if \u0026#39;b\u0026#39; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c \u0026#43; a % b); // There is no case in which this doesn\u0026#39;t hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026lt;= a); uint256 c = a - b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a \u0026#43; b; require(c \u0026gt;= a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.0; contract Cafe20{ using SafeMath for uint256; // creator address private _creator; // token name string private _name; // token symbol string private _symbol; // token totalSupply uint256 private _totalSupply; // address have how much token mapping (address =\u0026gt; uint256) private balances; // owner approve spender spend how much token mapping (address =\u0026gt; mapping (address =\u0026gt; uint256)) private allowances; constructor(string memory name_, string memory symbol_) public { _creator = theSender(); _name = name_; _symbol = symbol_; } /** * total tokens */ function totalSupply() public view returns (uint256) { return _totalSupply; } /** * mints tokens, only creator can call this function */ function mint(uint256 value) public returns (bool) { require(theSender() == _creator, \u0026#34;Cafe20: No permission\u0026#34;); _totalSupply = _totalSupply.add(value); balances[_creator] = balances[_creator].add(value); return true; } // when the token transfer, must be call this function event Transfer(address indexed _from, address indexed _to, uint256 _value); // when the approval, must be call this function event Approval(address indexed _owner, address indexed _spender, uint256 _value); /** * return this token\u0026#39;s name */ function name() public view returns (string memory) { return _name; } function creator() public view returns (address) { return _creator; } /** * return this token\u0026#39;s symbol */ function symbol() public view returns (string memory) { return _symbol; } /** * return this token\u0026#39;s number of decimal places */ function decimals() public view virtual returns (uint8) { return 5; } /* * return the sender\u0026#39;s balance */ function balance() public view returns (uint256 balance) { return balances[theSender()]; } /** * return the balance of this address */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } /** * transfer to address */ function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[theSender()] \u0026gt;= _value,\u0026#34;Cafe20: not enough balance\u0026#34;); require(_to != address(0), \u0026#34;Cafe20: can not to the zero address transfer\u0026#34;); balances[theSender()] = balances[theSender()].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(theSender(), _to, _value); return true; } /** * transfer from address to other address */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { if(theSender() == _from){ return transfer(_to, _value); } uint256 tokens = allowance(_from, theSender()); require(_from != address(0), \u0026#34;Cafe20: can not from the zero address transfer\u0026#34;); require(_to != address(0), \u0026#34;Cafe20: can not to the zero address transfer\u0026#34;); require(balances[_from] \u0026gt;= _value, \u0026#34;Cafe20: not enough tokens\u0026#34;); require(tokens \u0026gt;= _value, \u0026#34;Cafe20: the allowance not enough tokens\u0026#34;); // update balance balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); // update allowances allowances[_from][theSender()] = allowances[_from][theSender()].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * approve the spender for msg.sender */ function approve(address _spender, uint256 _value) public returns (bool success) { address _owner = theSender(); require(_spender != address(0), \u0026#34;Cafe20: can not approve the zero address\u0026#34;); require(balances[_owner] \u0026gt;= _value, \u0026#34;Cafe20: not enough tokens\u0026#34;); allowances[_owner][_spender] = allowances[_owner][_spender].add(_value); emit Approval(_owner, _spender, _value); return true; } /* * query the amount which _spender is still allowed to withdraw from _owner */ function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowances[_owner][_spender]; } /* * destroy the tokens */ function destroyTokens(uint256 _value) public returns (bool success) { require(balances[theSender()] \u0026gt;= _value, \u0026#34;Cafe20: not enough tokens\u0026#34;); balances[theSender()] = balances[theSender()].sub(_value); _totalSupply = _totalSupply.sub(_value); return true; } /* * msg.sender */ function theSender() private view returns (address) { return msg.sender; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring \u0026#39;a\u0026#39; not being zero, but the // benefit is lost if \u0026#39;b\u0026#39; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn\u0026#39;t hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026lt;= a); uint256 c = a - b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c \u0026gt;= a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } ","date":"2022-09-29T00:00:00Z","permalink":"https://superlitian.github.io/p/erc20/","title":"ERC20åˆçº¦"},{"content":"ERC721 solidity Copy // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.10; interface IERC721Receiver{ function onERC721Received( address operator, address from, uint256 tokenId, bytes calldata data ) external returns (bytes4); } contract Cafe721 { using SafeMath for uint256; //creator address private contractCreator; // name string private _name; // symbol string private _symbol; // Token struct Cafe { address creator; address owner; address approved; bytes32 summary; string uri; } // all Cafe mapping (uint256 =\u0026gt; Cafe) allCafe; // cafe\u0026#39;s counts uint256 _totalCafe; // User struct User { uint256[] cafes; uint256 totalCafe; } // all user mapping (address =\u0026gt; User) allUser; // operator approvals mapping (address =\u0026gt; mapping (address =\u0026gt; bool)) operatorApprovals; constructor(string memory name_, string memory symbol_){ contractCreator = theSender(); _name = name_; _symbol = symbol_; } event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); /* * the address have how much tokens */ function balanceOf(address _owner) external view returns (uint256 balance) { return allUser[_owner].totalCafe; } function cafesOf(address _owner) external view returns (uint256[] memory cafes){ return allUser[_owner].cafes; } /* * the token\u0026#39;s owner */ function ownerOf(uint256 _tokenId) external view returns (address owner) { return allCafe[_tokenId].owner; } function creatorOf(uint256 _tokenId) external view returns (address creator) { return allCafe[_tokenId].creator; } // trans begin function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool success) { // checked token require(exists(_tokenId), \u0026#34;Cafe721: the cafe is not exists\u0026#34;); // checked addr require(zeroAddr(_from), \u0026#34;Cafe721: can not from the zero address\u0026#34;); require(zeroAddr(_to), \u0026#34;Cafe721: can not to the zero address\u0026#34;); // checked permission require(isApprovedOrOwner(_tokenId), \u0026#34;Cafe721: no permission\u0026#34;); // remove cafe remove(_from, _tokenId); // transfer cafe allCafe[_tokenId].owner = _to; allCafe[_tokenId].approved = address(0); // add cafe allUser[_to].cafes.push(_tokenId); allUser[_to].totalCafe = allUser[_to].totalCafe.add(1); emit Transfer(_from, _to, _tokenId); return true; } function safeTransferFrom(address _from, address _to, uint256 _tokenId) external virtual returns (bool success) { return safeTransferFrom(_from, _to, _tokenId, \u0026#34;\u0026#34;); } function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public virtual returns (bool success) { require(isApprovedOrOwner(_tokenId), \u0026#34;Cafe721: no permission\u0026#34;); transferFrom(_from, _to, _tokenId); require(checkOnERC721Received(_from, _to, _tokenId, _data), \u0026#34;Cafe721: transfer to non ERC721Receiver implementer\u0026#34;); return true; } // trans end function approve(address _approved, uint256 _tokenId) external returns (bool success) { require(allCafe[_tokenId].owner == theSender(), \u0026#34;Cafe721: no permission\u0026#34;); require(_approved != theSender(), \u0026#34;Cafe721: can not approved for owner\u0026#34;); allCafe[_tokenId].approved = _approved; emit Approval(theSender(), _approved, _tokenId); return true; } function setApprovalForAll(address _operator, bool _approved) external returns (bool success) { require(_operator != theSender(), \u0026#34;Cafe721: can not approved for owner\u0026#34;); operatorApprovals[theSender()][_operator] = _approved; emit ApprovalForAll(theSender(), _operator, _approved); return true; } function getApproved(uint256 _tokenId) private view returns(address) { return allCafe[_tokenId].approved; } function isApprovedForAll(address _owner, address _operator) public view returns (bool) { return operatorApprovals[_owner][_operator]; } function name() external view returns (string memory) { return _name; } function symbol() external view returns (string memory) { return _symbol; } function tokenURI(uint256 _tokenId) external view returns (string memory uri) { return allCafe[_tokenId].uri; } function tokenSummary(uint256 _tokenId) external view returns (bytes32 summary) { return allCafe[_tokenId].summary; } function totalSupply() external view returns (uint256 totalCafe) { return _totalCafe; } function exists(uint256 _tokenId) internal view returns (bool){ return allCafe[_tokenId].owner != address(0); } function zeroAddr(address addr) private pure returns (bool) { return addr != address(0); } function remove(address _from, uint256 _tokenId) private { uint[] storage cafes = allUser[_from].cafes; for (uint i = 0; i \u0026lt; cafes.length - 1; i\u0026#43;\u0026#43;){ if(cafes[i] == _tokenId){ cafes[i] = cafes[cafes.length \u0026#43; 1]; break; } } delete cafes[cafes.length - 1]; cafes.pop(); allUser[_from].cafes = cafes; allUser[_from].totalCafe = allUser[_from].totalCafe.sub(1); } /* * address owner; * address approved; * bytes32 summary; * string uri; */ function mint(uint256 _tokenId, bytes32 _summary, string memory _uri) external { require(allCafe[_tokenId].creator == address(0), \u0026#34;Cafe721: the cafe is exists.\u0026#34;); allCafe[_tokenId].creator = theSender(); allCafe[_tokenId].owner = theSender(); allCafe[_tokenId].approved = address(0); allCafe[_tokenId].summary = _summary; allCafe[_tokenId].uri = _uri; // User allUser[theSender()].cafes.push(_tokenId); allUser[theSender()].totalCafe = allUser[theSender()].totalCafe.add(1); _totalCafe = _totalCafe.add(1); } function isApprovedOrOwner(uint256 _tokenId) private view returns (bool) { require(exists(_tokenId), \u0026#34;Cafe721: the cafe is exists.\u0026#34;); return (theSender() == allCafe[_tokenId].owner || isApprovedForAll(allCafe[_tokenId].owner, theSender()) || getApproved(_tokenId) == theSender()); } function checkOnERC721Received(address from,address to,uint256 tokenId,bytes memory _data) private returns (bool) { if (to.code.length \u0026gt; 0) { try IERC721Receiver(to).onERC721Received(theSender(), from, tokenId, _data) returns (bytes4 retval) { return retval == IERC721Receiver.onERC721Received.selector; } catch (bytes memory reason) { if (reason.length == 0) { revert(\u0026#34;ERC721: transfer to non ERC721Receiver implementer\u0026#34;); } else { assembly { revert(add(32, reason), mload(reason)) } } } } else { return true; } } // destroyCafe function destroyCafe(uint256 _tokenId) external returns (bool success) { require(allCafe[_tokenId].owner == theSender(), \u0026#34;Cafe721: no premission\u0026#34;); remove(theSender(), _tokenId); delete allCafe[_tokenId]; _totalCafe = _totalCafe.sub(1); return true; } function theSender() internal view returns (address) { return msg.sender; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring \u0026#39;a\u0026#39; not being zero, but the // benefit is lost if \u0026#39;b\u0026#39; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c \u0026#43; a % b); // There is no case in which this doesn\u0026#39;t hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026lt;= a); uint256 c = a - b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a \u0026#43; b; require(c \u0026gt;= a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.10; interface IERC721Receiver{ function onERC721Received( address operator, address from, uint256 tokenId, bytes calldata data ) external returns (bytes4); } contract Cafe721 { using SafeMath for uint256; //creator address private contractCreator; // name string private _name; // symbol string private _symbol; // Token struct Cafe { address creator; address owner; address approved; bytes32 summary; string uri; } // all Cafe mapping (uint256 =\u0026gt; Cafe) allCafe; // cafe\u0026#39;s counts uint256 _totalCafe; // User struct User { uint256[] cafes; uint256 totalCafe; } // all user mapping (address =\u0026gt; User) allUser; // operator approvals mapping (address =\u0026gt; mapping (address =\u0026gt; bool)) operatorApprovals; constructor(string memory name_, string memory symbol_){ contractCreator = theSender(); _name = name_; _symbol = symbol_; } event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); /* * the address have how much tokens */ function balanceOf(address _owner) external view returns (uint256 balance) { return allUser[_owner].totalCafe; } function cafesOf(address _owner) external view returns (uint256[] memory cafes){ return allUser[_owner].cafes; } /* * the token\u0026#39;s owner */ function ownerOf(uint256 _tokenId) external view returns (address owner) { return allCafe[_tokenId].owner; } function creatorOf(uint256 _tokenId) external view returns (address creator) { return allCafe[_tokenId].creator; } // trans begin function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool success) { // checked token require(exists(_tokenId), \u0026#34;Cafe721: the cafe is not exists\u0026#34;); // checked addr require(zeroAddr(_from), \u0026#34;Cafe721: can not from the zero address\u0026#34;); require(zeroAddr(_to), \u0026#34;Cafe721: can not to the zero address\u0026#34;); // checked permission require(isApprovedOrOwner(_tokenId), \u0026#34;Cafe721: no permission\u0026#34;); // remove cafe remove(_from, _tokenId); // transfer cafe allCafe[_tokenId].owner = _to; allCafe[_tokenId].approved = address(0); // add cafe allUser[_to].cafes.push(_tokenId); allUser[_to].totalCafe = allUser[_to].totalCafe.add(1); emit Transfer(_from, _to, _tokenId); return true; } function safeTransferFrom(address _from, address _to, uint256 _tokenId) external virtual returns (bool success) { return safeTransferFrom(_from, _to, _tokenId, \u0026#34;\u0026#34;); } function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public virtual returns (bool success) { require(isApprovedOrOwner(_tokenId), \u0026#34;Cafe721: no permission\u0026#34;); transferFrom(_from, _to, _tokenId); require(checkOnERC721Received(_from, _to, _tokenId, _data), \u0026#34;Cafe721: transfer to non ERC721Receiver implementer\u0026#34;); return true; } // trans end function approve(address _approved, uint256 _tokenId) external returns (bool success) { require(allCafe[_tokenId].owner == theSender(), \u0026#34;Cafe721: no permission\u0026#34;); require(_approved != theSender(), \u0026#34;Cafe721: can not approved for owner\u0026#34;); allCafe[_tokenId].approved = _approved; emit Approval(theSender(), _approved, _tokenId); return true; } function setApprovalForAll(address _operator, bool _approved) external returns (bool success) { require(_operator != theSender(), \u0026#34;Cafe721: can not approved for owner\u0026#34;); operatorApprovals[theSender()][_operator] = _approved; emit ApprovalForAll(theSender(), _operator, _approved); return true; } function getApproved(uint256 _tokenId) private view returns(address) { return allCafe[_tokenId].approved; } function isApprovedForAll(address _owner, address _operator) public view returns (bool) { return operatorApprovals[_owner][_operator]; } function name() external view returns (string memory) { return _name; } function symbol() external view returns (string memory) { return _symbol; } function tokenURI(uint256 _tokenId) external view returns (string memory uri) { return allCafe[_tokenId].uri; } function tokenSummary(uint256 _tokenId) external view returns (bytes32 summary) { return allCafe[_tokenId].summary; } function totalSupply() external view returns (uint256 totalCafe) { return _totalCafe; } function exists(uint256 _tokenId) internal view returns (bool){ return allCafe[_tokenId].owner != address(0); } function zeroAddr(address addr) private pure returns (bool) { return addr != address(0); } function remove(address _from, uint256 _tokenId) private { uint[] storage cafes = allUser[_from].cafes; for (uint i = 0; i \u0026lt; cafes.length - 1; i++){ if(cafes[i] == _tokenId){ cafes[i] = cafes[cafes.length + 1]; break; } } delete cafes[cafes.length - 1]; cafes.pop(); allUser[_from].cafes = cafes; allUser[_from].totalCafe = allUser[_from].totalCafe.sub(1); } /* * address owner; * address approved; * bytes32 summary; * string uri; */ function mint(uint256 _tokenId, bytes32 _summary, string memory _uri) external { require(allCafe[_tokenId].creator == address(0), \u0026#34;Cafe721: the cafe is exists.\u0026#34;); allCafe[_tokenId].creator = theSender(); allCafe[_tokenId].owner = theSender(); allCafe[_tokenId].approved = address(0); allCafe[_tokenId].summary = _summary; allCafe[_tokenId].uri = _uri; // User allUser[theSender()].cafes.push(_tokenId); allUser[theSender()].totalCafe = allUser[theSender()].totalCafe.add(1); _totalCafe = _totalCafe.add(1); } function isApprovedOrOwner(uint256 _tokenId) private view returns (bool) { require(exists(_tokenId), \u0026#34;Cafe721: the cafe is exists.\u0026#34;); return (theSender() == allCafe[_tokenId].owner || isApprovedForAll(allCafe[_tokenId].owner, theSender()) || getApproved(_tokenId) == theSender()); } function checkOnERC721Received(address from,address to,uint256 tokenId,bytes memory _data) private returns (bool) { if (to.code.length \u0026gt; 0) { try IERC721Receiver(to).onERC721Received(theSender(), from, tokenId, _data) returns (bytes4 retval) { return retval == IERC721Receiver.onERC721Received.selector; } catch (bytes memory reason) { if (reason.length == 0) { revert(\u0026#34;ERC721: transfer to non ERC721Receiver implementer\u0026#34;); } else { assembly { revert(add(32, reason), mload(reason)) } } } } else { return true; } } // destroyCafe function destroyCafe(uint256 _tokenId) external returns (bool success) { require(allCafe[_tokenId].owner == theSender(), \u0026#34;Cafe721: no premission\u0026#34;); remove(theSender(), _tokenId); delete allCafe[_tokenId]; _totalCafe = _totalCafe.sub(1); return true; } function theSender() internal view returns (address) { return msg.sender; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring \u0026#39;a\u0026#39; not being zero, but the // benefit is lost if \u0026#39;b\u0026#39; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn\u0026#39;t hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026lt;= a); uint256 c = a - b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c \u0026gt;= a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } ","date":"2022-09-29T00:00:00Z","permalink":"https://superlitian.github.io/p/erc721/","title":"ERC721åˆçº¦"},{"content":"ä¸¤ç§æ–¹æ³•è§£å†³ å°†value è½¬ä¸º 16è¿›åˆ¶æˆ–base64ï¼ŒæœåŠ¡ç«¯å•ç‹¬åšä¸€å±‚è§£ç \ngo Copy bt := []byte{230,136} hexStr := hex.EncodeToString(bt) args := map[string]string{} args[\u0026#34;a\u0026#34;] = hexStr fmt.Printf(\u0026#34;a %v\\n\u0026#34;,bt) println(\u0026#34;len a\u0026#34;, len(bt)) input, err := json.Marshal(args) if err != nil { fmt.Println(err) } var decodeArgs map[string]string err =json.Unmarshal(input, \u0026amp;decodeArgs) if err != nil { return } b, err := hex.DecodeString(decodeArgs[\u0026#34;a\u0026#34;]) if err != nil { return } fmt.Println(\u0026#34;b\u0026#34;, b) fmt.Println(\u0026#34;len b\u0026#34;, len(b)) // output a [230 136] len a 2 b [230 136] len b 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 bt := []byte{230,136} hexStr := hex.EncodeToString(bt) args := map[string]string{} args[\u0026#34;a\u0026#34;] = hexStr fmt.Printf(\u0026#34;a %v\\n\u0026#34;,bt) println(\u0026#34;len a\u0026#34;, len(bt)) input, err := json.Marshal(args) if err != nil { fmt.Println(err) } var decodeArgs map[string]string err =json.Unmarshal(input, \u0026amp;decodeArgs) if err != nil { return } b, err := hex.DecodeString(decodeArgs[\u0026#34;a\u0026#34;]) if err != nil { return } fmt.Println(\u0026#34;b\u0026#34;, b) fmt.Println(\u0026#34;len b\u0026#34;, len(b)) // output a [230 136] len a 2 b [230 136] len b 2 æœåŠ¡ç«¯å£°æ˜ä¸€ä¸ªå¯¹åº”çš„æ¥æ”¶struct\ngo Copy type tb struct { Bytes []byte } func test() { bt := []byte{230,136} args := tb{Bytes: bt} fmt.Printf(\u0026#34;a %v\\n\u0026#34;,bt) println(\u0026#34;len a\u0026#34;, len(bt)) input, err := json.Marshal(args) if err != nil { fmt.Println(err) } var decodeArgs tb err =json.Unmarshal(input, \u0026amp;decodeArgs) if err != nil { return } if err != nil { return } fmt.Println(\u0026#34;b\u0026#34;, decodeArgs.Bytes) fmt.Println(\u0026#34;len b\u0026#34;, len(decodeArgs.Bytes)) } // output a [230 136] len a 2 b [230 136] len b 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 type tb struct { Bytes []byte } func test() { bt := []byte{230,136} args := tb{Bytes: bt} fmt.Printf(\u0026#34;a %v\\n\u0026#34;,bt) println(\u0026#34;len a\u0026#34;, len(bt)) input, err := json.Marshal(args) if err != nil { fmt.Println(err) } var decodeArgs tb err =json.Unmarshal(input, \u0026amp;decodeArgs) if err != nil { return } if err != nil { return } fmt.Println(\u0026#34;b\u0026#34;, decodeArgs.Bytes) fmt.Println(\u0026#34;len b\u0026#34;, len(decodeArgs.Bytes)) } // output a [230 136] len a 2 b [230 136] len b 2 ","date":"2022-09-29T00:00:00Z","permalink":"https://superlitian.github.io/p/gojsonquestion/","title":"go json åºåˆ—åŒ–é—®é¢˜"},{"content":"Kates åŸºäºdiscord + ç™¾åº¦æ™ºèƒ½äº‘è‡ªåŠ¨å¯¹è¯unitå¹³å°å®ç°ç¤¾åŒºæ²»ç†æœºå™¨äººã€‚\nmian.py python Copy #!/usr/bin/env python3 import discord import re import unit intents = discord.Intents.default() intents.members = True client = discord.Client(proxy=\u0026#34;http://127.0.0.1:7890\u0026#34;, intents=intents) # discord æœºå™¨äºº token token = \u0026#39;\u0026#39; @client.event async def on_ready(): print(\u0026#34;Bot client logged-in as: %s\u0026#34; % client.user) @client.event async def on_member_join(member): str = discord.Embed(title=\u0026#34;ğŸ‘ğŸ»ğŸ‘ğŸ»ğŸ‘ğŸ»ğŸ‘ğŸ»ğŸ‘ğŸ»\u0026#34;,description=f\u0026#34;Hi, {member.mention},\u0026#34; f\u0026#34; æ¬¢è¿ä½ æ¥åˆ°{member.guild.name}ç¤¾åŒº\u0026#34;, color=0x00ff00) # await member.create_dm() # await member.dm_channel.send(embed=str) # é¢‘é“ç®¡é“ channel = client.get_channel() await channel.send(embed=str) @client.event async def on_message(message): # æ’é™¤botè‡ªèº«çš„æ¶ˆæ¯ if message.author == client.user: return # ping/pongæµ‹è¯•ï¼Œç„¶ååˆ é™¤æµ‹è¯•æ¶ˆæ¯ if message.content == \u0026#39;welcome\u0026#39;: await on_member_join(message.author) # è¿”å›atæœºå™¨äººçš„æ¶ˆæ¯ elif client.user.mentioned_in(message): trim_mentioned_msg = re.sub(\u0026#34;\u0026lt;@!?(\\d\u0026#43;)\u0026gt;\u0026#34;, \u0026#34;\u0026#34;, message.content).strip() # è°ƒç”¨ç™¾åº¦æ™ºèƒ½æœºå™¨äºº await message.channel.send( f\u0026#34;{message.author.mention} {unit.talk(trim_mentioned_msg)}\u0026#34;) # www.baidu.com if __name__ == \u0026#34;__main__\u0026#34;: unit.get_token() client.run(token) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #!/usr/bin/env python3 import discord import re import unit intents = discord.Intents.default() intents.members = True client = discord.Client(proxy=\u0026#34;http://127.0.0.1:7890\u0026#34;, intents=intents) # discord æœºå™¨äºº token token = \u0026#39;\u0026#39; @client.event async def on_ready(): print(\u0026#34;Bot client logged-in as: %s\u0026#34; % client.user) @client.event async def on_member_join(member): str = discord.Embed(title=\u0026#34;ğŸ‘ğŸ»ğŸ‘ğŸ»ğŸ‘ğŸ»ğŸ‘ğŸ»ğŸ‘ğŸ»\u0026#34;,description=f\u0026#34;Hi, {member.mention},\u0026#34; f\u0026#34; æ¬¢è¿ä½ æ¥åˆ°{member.guild.name}ç¤¾åŒº\u0026#34;, color=0x00ff00) # await member.create_dm() # await member.dm_channel.send(embed=str) # é¢‘é“ç®¡é“ channel = client.get_channel() await channel.send(embed=str) @client.event async def on_message(message): # æ’é™¤botè‡ªèº«çš„æ¶ˆæ¯ if message.author == client.user: return # ping/pongæµ‹è¯•ï¼Œç„¶ååˆ é™¤æµ‹è¯•æ¶ˆæ¯ if message.content == \u0026#39;welcome\u0026#39;: await on_member_join(message.author) # è¿”å›atæœºå™¨äººçš„æ¶ˆæ¯ elif client.user.mentioned_in(message): trim_mentioned_msg = re.sub(\u0026#34;\u0026lt;@!?(\\d+)\u0026gt;\u0026#34;, \u0026#34;\u0026#34;, message.content).strip() # è°ƒç”¨ç™¾åº¦æ™ºèƒ½æœºå™¨äºº await message.channel.send( f\u0026#34;{message.author.mention} {unit.talk(trim_mentioned_msg)}\u0026#34;) # www.baidu.com if __name__ == \u0026#34;__main__\u0026#34;: unit.get_token() client.run(token) unit.py python Copy import json import time import requests Token = \u0026#34;\u0026#34; def talk(text): url = \u0026#39;https://aip.baidubce.com/rpc/2.0/unit/service/v3/chat?access_token=\u0026#39; \u0026#43; Token request = { \u0026#39;terminal_id\u0026#39;: \u0026#39;123456\u0026#39;, \u0026#39;query\u0026#39;: text } param = { \u0026#39;version\u0026#39;: \u0026#39;3.0\u0026#39;, \u0026#39;service_id\u0026#39;: \u0026#39;S71734\u0026#39;, \u0026#39;session_id\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;log_id\u0026#39;: str(time.time()), \u0026#39;request\u0026#39;: request } headers = {\u0026#39;content-type\u0026#39;: \u0026#39;application/json\u0026#39;} response = requests.post(url, data=json.dumps(param), headers=headers) if response: print(response.json()) return response.json()[\u0026#39;result\u0026#39;][\u0026#39;context\u0026#39;][\u0026#39;SYS_PRESUMED_HIST\u0026#39;][1] else: return \u0026#34;æˆ‘ä¹Ÿä¸æ˜¯å¤ªæ˜ç™½~\u0026#34; def get_token(): global Token # ç™¾åº¦æ™ºèƒ½äº‘é‰´æƒä¿¡æ¯ ak = \u0026#39;\u0026#39; sk = \u0026#39;\u0026#39; host = f\u0026#39;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials\u0026amp;client_id={ak}\u0026amp;client_secret={sk}\u0026#39; response = requests.get(host) if response: Token = response.json()[\u0026#39;access_token\u0026#39;] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import json import time import requests Token = \u0026#34;\u0026#34; def talk(text): url = \u0026#39;https://aip.baidubce.com/rpc/2.0/unit/service/v3/chat?access_token=\u0026#39; + Token request = { \u0026#39;terminal_id\u0026#39;: \u0026#39;123456\u0026#39;, \u0026#39;query\u0026#39;: text } param = { \u0026#39;version\u0026#39;: \u0026#39;3.0\u0026#39;, \u0026#39;service_id\u0026#39;: \u0026#39;S71734\u0026#39;, \u0026#39;session_id\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;log_id\u0026#39;: str(time.time()), \u0026#39;request\u0026#39;: request } headers = {\u0026#39;content-type\u0026#39;: \u0026#39;application/json\u0026#39;} response = requests.post(url, data=json.dumps(param), headers=headers) if response: print(response.json()) return response.json()[\u0026#39;result\u0026#39;][\u0026#39;context\u0026#39;][\u0026#39;SYS_PRESUMED_HIST\u0026#39;][1] else: return \u0026#34;æˆ‘ä¹Ÿä¸æ˜¯å¤ªæ˜ç™½~\u0026#34; def get_token(): global Token # ç™¾åº¦æ™ºèƒ½äº‘é‰´æƒä¿¡æ¯ ak = \u0026#39;\u0026#39; sk = \u0026#39;\u0026#39; host = f\u0026#39;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials\u0026amp;client_id={ak}\u0026amp;client_secret={sk}\u0026#39; response = requests.get(host) if response: Token = response.json()[\u0026#39;access_token\u0026#39;] ","date":"2022-09-29T00:00:00Z","image":"https://superlitian.github.io/p/kates/kates_hu38fc63566810e7ae399e2f7c8a810aeb_244696_120x120_fill_q75_box_smart1.jpg","permalink":"https://superlitian.github.io/p/kates/","title":"Kates - discord æœºå™¨äºº"},{"content":"Short_content åˆçº¦è®¾è®¡ æŸ¥è¯¢é€»è¾‘ æ ¹æ® userid æŸ¥è¯¢ï¼Œç»“æœä¸ºä¸€ä¸ªé›†åˆã€‚é›†åˆå†…å®¹ä¸ºå®Œæ•´çš„å­˜è¯ä¿¡æ¯ï¼šæ ‡é¢˜ã€ç±»åˆ«ã€å†…å®¹ã€‚ æ ¹æ® userid + title æŸ¥è¯¢ï¼Œç»“æœä¸ºä¸€ä¸ªå­—ç¬¦ä¸²ã€‚å†…å®¹ä¸ºä¸€ä¸ªå®Œæ•´çš„å­˜è¯ä¿¡æ¯ï¼šæ ‡é¢˜ã€ç±»åˆ«ã€å†…å®¹ã€‚æ ‡é¢˜ = titleã€‚ æ ¹æ® userid + topic æŸ¥è¯¢ï¼Œç»“æœä¸ºä¸€ä¸ªé›†åˆã€‚å†…å®¹ä¸ºå®Œæ•´çš„å­˜è¯ä¿¡æ¯ï¼šæ ‡é¢˜ã€ç±»åˆ«ã€å†…å®¹ã€‚åŒºåˆ«åœ¨äºæ‰€æœ‰ç±»åˆ« = topicã€‚ æ€ä¹ˆè®¾è®¡ userid\nuserid éœ€è¦å¯¹åº”ä¸€ä¸ªé›†åˆã€‚å¯¹åº”å“ªä¸ªé›†åˆï¼Ÿ\nMapping(userid =\u0026gt; ?[]) useridToContent\ntopic\ntopic ä¹Ÿéœ€è¦å¯¹åº”ä¸€ä¸ªé›†åˆï¼Œä½†æ˜¯ç´¢å¼•é”®ä¸º userid + topicï¼Œ æ€ä¹ˆè®¾è®¡ï¼Ÿ\nMapping(userid+topic =\u0026gt; ?[]) topics\ntitle\ntitle ä¸éœ€è¦é›†åˆï¼Œä½†æ˜¯è¡¨ç°å½¢å¼åº”è¯¥ä¸ºï¼š userid + title = content çš„æ‰€æœ‰å†…å®¹ã€‚\nMapping(userid + title =\u0026gt; ?) Article\nå¼•å…¥ä¸€ä¸ªç»“æ„ä½“èƒ½è§£å†³è¿™ä¸ªé—®é¢˜å—ï¼Ÿ\nsolidity Copy // è¯¥ç»“æ„ä½“æ˜¯å¦è¦åŒ…å«userid? å…ˆä¸åŒ…å«å†™ä¸€ä¸‹çœ‹ struct Article{ string title; string topic; string content; } // userid æ€ä¹ˆä¸ Article å¯¹åº”ï¼Ÿ mapping(string =\u0026gt; Article[]) allArticle ? // é‚£ä¹ˆcreate æ€ä¹ˆæ“ä½œï¼Ÿ function create(string userid, string title, string topic, string content){ Article a = Article{ title: title, topic: topic, content: conten }; allArtcile[userid].push(a); // è¿™æ ·çœ‹èµ·æ¥æ²¡é—®é¢˜ï¼Œ userid åˆ° article çš„æ˜ å°„å¯ä»¥è§£å†³ï¼Œä½†æ˜¯æ€ä¹ˆæŸ¥è¯¢å‘¢ï¼Ÿ return allArtcile[userid] ? è¿™æ ·è¿”å›çš„æ˜¯ç»“æ„ä½“æ•°ç»„ï¼Œç”šè‡³ä¸æ˜¯stirng æ•°ç»„ï¼Œ evm æ”¯æŒå—ï¼Ÿ // todo: ç¡®è®¤evm æ˜¯å¦æ”¯æŒ struct[] è¿”å›ï¼Œä»¥åŠ xchain æ˜¯å¦æ”¯æŒã€‚ } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // è¯¥ç»“æ„ä½“æ˜¯å¦è¦åŒ…å«userid? å…ˆä¸åŒ…å«å†™ä¸€ä¸‹çœ‹ struct Article{ string title; string topic; string content; } // userid æ€ä¹ˆä¸ Article å¯¹åº”ï¼Ÿ mapping(string =\u0026gt; Article[]) allArticle ? // é‚£ä¹ˆcreate æ€ä¹ˆæ“ä½œï¼Ÿ function create(string userid, string title, string topic, string content){ Article a = Article{ title: title, topic: topic, content: conten }; allArtcile[userid].push(a); // è¿™æ ·çœ‹èµ·æ¥æ²¡é—®é¢˜ï¼Œ userid åˆ° article çš„æ˜ å°„å¯ä»¥è§£å†³ï¼Œä½†æ˜¯æ€ä¹ˆæŸ¥è¯¢å‘¢ï¼Ÿ return allArtcile[userid] ? è¿™æ ·è¿”å›çš„æ˜¯ç»“æ„ä½“æ•°ç»„ï¼Œç”šè‡³ä¸æ˜¯stirng æ•°ç»„ï¼Œ evm æ”¯æŒå—ï¼Ÿ // todo: ç¡®è®¤evm æ˜¯å¦æ”¯æŒ struct[] è¿”å›ï¼Œä»¥åŠ xchain æ˜¯å¦æ”¯æŒã€‚ } Evm æ˜¯æ”¯æŒè¿™æ ·å†™çš„ï¼Œä½†æ³¨æ„è¦æ·»åŠ  pragma experimental ABIEncoderV2;\né‚£ä¹ˆæ­¤åˆçº¦é‡åˆ°çš„é—®é¢˜ä¾¿è¿åˆƒè€Œè§£ï¼Œä½†æ˜¯éœ€è¦åšå¾ªç¯åŒ¹é…topic title è¿™äº›ï¼Œæ€»çš„æ¥è¯´ï¼Œè¿™ä¸ªåˆçº¦ä¸æ˜¯éå¸¸åˆç†\nä¸ºäº†æ›´åˆç†çš„è®¾è®¡åˆçº¦ï¼Œå†³å®šç”¨å¤šä¸ª mapping æ¥è¿›è¡ŒåŒ¹é…\nåˆçº¦å®ç° solidity Copy // SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.7.4; pragma experimental ABIEncoderV2; contract ShortContent{ // userid å¯¹åº”ä¸€ä¸ªé›†åˆï¼Œ userid =\u0026gt; title\u0026#43;topic\u0026#43;content mapping(string =\u0026gt; string[]) userArticles; // userid \u0026#43; topic å¯¹åº”ä¸€ä¸ªé›†åˆ userid \u0026#43; topic =\u0026gt; title \u0026#43; topic \u0026#43; content mapping(string =\u0026gt; string[]) utopicArticles; // userid \u0026#43; title å¯¹åº”ä¸€ç¯‡æ–‡ç«  userid \u0026#43; title =\u0026gt; title \u0026#43; topic \u0026#43; content mapping(string =\u0026gt; string) utitleArticles; // é•¿åº¦é™åˆ¶ uint256 maxTopicLen; uint256 maxTitleLen; uint256 maxContentLen; constructor(){ maxTopicLen = 36; maxTitleLen = 100; maxContentLen = 3000; } function storeShortContent(string memory userid, string memory title, string memory topic, string memory content) external returns (string memory message) { // é•¿åº¦æ£€éªŒ require(bytes(title).length \u0026lt; maxTitleLen, \u0026#34;this title is too long\u0026#34;); require(bytes(topic).length \u0026lt; maxTopicLen, \u0026#34;this topic is too long\u0026#34;); require(bytes(content).length \u0026lt; maxContentLen, \u0026#34;this content is too long\u0026#34;); // æ·»åŠ æ˜ å°„ string memory result = string(abi.encodePacked(userid,\u0026#34;/\u0026#34;,title,\u0026#34;/\u0026#34;,topic,\u0026#34;/\u0026#34;,content)); string memory utopic = string(abi.encodePacked(userid,topic)); string memory utitle = string(abi.encodePacked(userid,title)); userArticles[userid].push(result); utopicArticles[utopic].push(result); utitleArticles[utitle] = result; return \u0026#34;store short content success\u0026#34;; } function queryByUser(string memory userid) public view returns(string[] memory articles){ return userArticles[userid]; } function queryByTopic(string memory userid, string memory topic) public view returns(string[] memory articles){ string memory utopic = string(abi.encodePacked(userid,topic)); return utopicArticles[utopic]; } function queryByTitle(string memory userid, string memory title) public view returns(string memory articles){ string memory utitle = string(abi.encodePacked(userid,title)); return utitleArticles[utitle]; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.7.4; pragma experimental ABIEncoderV2; contract ShortContent{ // userid å¯¹åº”ä¸€ä¸ªé›†åˆï¼Œ userid =\u0026gt; title+topic+content mapping(string =\u0026gt; string[]) userArticles; // userid + topic å¯¹åº”ä¸€ä¸ªé›†åˆ userid + topic =\u0026gt; title + topic + content mapping(string =\u0026gt; string[]) utopicArticles; // userid + title å¯¹åº”ä¸€ç¯‡æ–‡ç«  userid + title =\u0026gt; title + topic + content mapping(string =\u0026gt; string) utitleArticles; // é•¿åº¦é™åˆ¶ uint256 maxTopicLen; uint256 maxTitleLen; uint256 maxContentLen; constructor(){ maxTopicLen = 36; maxTitleLen = 100; maxContentLen = 3000; } function storeShortContent(string memory userid, string memory title, string memory topic, string memory content) external returns (string memory message) { // é•¿åº¦æ£€éªŒ require(bytes(title).length \u0026lt; maxTitleLen, \u0026#34;this title is too long\u0026#34;); require(bytes(topic).length \u0026lt; maxTopicLen, \u0026#34;this topic is too long\u0026#34;); require(bytes(content).length \u0026lt; maxContentLen, \u0026#34;this content is too long\u0026#34;); // æ·»åŠ æ˜ å°„ string memory result = string(abi.encodePacked(userid,\u0026#34;/\u0026#34;,title,\u0026#34;/\u0026#34;,topic,\u0026#34;/\u0026#34;,content)); string memory utopic = string(abi.encodePacked(userid,topic)); string memory utitle = string(abi.encodePacked(userid,title)); userArticles[userid].push(result); utopicArticles[utopic].push(result); utitleArticles[utitle] = result; return \u0026#34;store short content success\u0026#34;; } function queryByUser(string memory userid) public view returns(string[] memory articles){ return userArticles[userid]; } function queryByTopic(string memory userid, string memory topic) public view returns(string[] memory articles){ string memory utopic = string(abi.encodePacked(userid,topic)); return utopicArticles[utopic]; } function queryByTitle(string memory userid, string memory title) public view returns(string memory articles){ string memory utitle = string(abi.encodePacked(userid,title)); return utitleArticles[utitle]; } } xchainæµ‹è¯• ç¼–è¯‘åˆçº¦\nsolcjs --abi --bin ./short_content.sol -o build\næµ‹è¯•å­˜å‚¨\næµ‹è¯•æŸ¥è¯¢\n","date":"2022-09-28T00:00:00Z","image":"https://superlitian.github.io/p/shortcontent/header_hu58eb6555178a77861c10495595dbf0eb_18332_120x120_fill_q75_box_smart1.jpg","permalink":"https://superlitian.github.io/p/shortcontent/","title":"çŸ­å†…å®¹å­˜è¯åˆçº¦"},{"content":"åˆçº¦ä»‹ç» åœºæ™¯ä»‹ç» campaign åˆçº¦ï¼Œå®ç°åœºæ™¯ä¸ºå­¦ç”Ÿä¼šä¸»å¸­ç«é€‰æµç¨‹ã€‚\næµç¨‹ä»‹ç» åˆçº¦åˆå§‹åŒ–æ—¶ï¼ŒæŒ‡å®šå…·æœ‰owneræƒé™çš„è´¦æˆ·ï¼Œè¯¥è´¦æˆ·å…·æœ‰æ£€ç¥¨ä¸æåå€™é€‰äººä»¥åŠå¯åŠ¨ç«é€‰ææ¡ˆçš„æƒåˆ©ã€‚ å¯åŠ¨ç«é€‰ææ¡ˆï¼Œéœ€è¦æåä¸€ä½å€™é€‰äººï¼Œå¹¶æŒ‡å®šææ¡ˆé€šè¿‡ç¥¨æ•°é˜ˆå€¼ï¼Œæ›´æ–°ææ¡ˆçŠ¶æ€ä¸ºæŠ•ç¥¨ä¸­ï¼Œè¿”å›è¯¥æ¬¡ææ¡ˆIDã€‚ ä»»ä½•äººéƒ½å¯ä»¥æ ¹æ®ææ¡ˆIDæŸ¥è¯¢è¯¥ææ¡ˆçš„çŠ¶æ€ã€‚ å½“ææ¡ˆçŠ¶æ€ä¸ºæŠ•ç¥¨ä¸­ï¼Œä»»ä½•äººå¯ä»¥è°ƒç”¨æŠ•ç¥¨åŠŸèƒ½è¿›è¡ŒæŠ•ç¥¨ï¼Œé™æŠ•ä¸€äººä¸€ç¥¨ï¼Œé‡å¤æŠ•ç¥¨ä¸ä¼šç”Ÿæ•ˆã€‚ å½“ç¥¨æ•°å¤§äºå¯åŠ¨ææ¡ˆæ—¶è®¾ç½®çš„é˜ˆå€¼ï¼Œææ¡ˆçŠ¶æ€ä¸ºå¾…æ£€ç¥¨ï¼Œowner å¯å¯åŠ¨æ£€ç¥¨ã€‚ æ£€ç¥¨ä¼šè¿›è¡Œèº«ä»½éªŒè¯ï¼Œåªæœ‰ownerè´¦æˆ·å¯ä»¥æˆåŠŸè°ƒç”¨ã€‚ æ£€ç¥¨é€šè¿‡åï¼Œææ¡ˆæµç¨‹ç»“æŸï¼Œææ¡ˆçŠ¶æ€ç½®ä¸ºå·²ç”Ÿæ•ˆï¼Œæ­¤æ—¶ä»»ä½•äººéƒ½å¯ä»¥æŸ¥è¯¢å½“å‰å­¦ç”Ÿä¼šä¸»å¸­ä¿¡æ¯ã€‚ å½“ææ¡ˆçŠ¶æ€ä¸ºæœªå¯åŠ¨ã€å·²ç”Ÿæ•ˆã€å¾…æ£€ç¥¨æ—¶ï¼Œä¸å¯ä½¿ç”¨æŠ•ç¥¨åŠŸèƒ½ã€‚ ä»»ä½•äººéƒ½å¯æ ¹æ®ææ¡ˆIDæŸ¥è¯¢è¯¥ææ¡ˆçš„å€™é€‰äººä¿¡æ¯ã€‚ åŠŸèƒ½ä»‹ç» constructor Params: owner: type: address desc: owneræƒé™è®¾ç½® Desc: è®¾ç½®owneræƒé™è´¦æˆ·ï¼Œåˆå§‹åŒ–ææ¡ˆçŠ¶æ€ propose Params: candidate: type: string desc: å€™é€‰äºº target: type: uint256 desc: ç¥¨æ•°é˜ˆå€¼ Returns: proposalId: type: uint256 desc: ææ¡ˆID Desc: å¯åŠ¨ç«é€‰ææ¡ˆ queryProposal Params:\nproposalId: type: uint256 desc: ææ¡ˆID Returns:\nstatus: type: string desc: ææ¡ˆçŠ¶æ€ï¼šæœªå¯åŠ¨(stoped)ã€æŠ•ç¥¨ä¸­(voting)ã€å¾…æ£€ç¥¨(passed)ã€å·²ç”Ÿæ•ˆ(completed) Desc: æŸ¥è¯¢ææ¡ˆçŠ¶æ€\nvote Params:\nproposalId: type: uint256 desc: ææ¡ˆID Retruns:\nstatus: type: string desc: æŠ•ç¥¨çŠ¶æ€ï¼š\u0026ldquo;success\u0026rdquo; or \u0026ldquo;error\u0026rdquo;ï¼Œerroréœ€ç»™å‡ºåŸå›  Desc: è¿›è¡ŒæŠ•ç¥¨ï¼Œè°ƒç”¨è¯¥æ–¹æ³•ï¼Œè§†ä¸ºè°ƒç”¨è€…è¿›è¡ŒæŠ•ç¥¨ä¸€æ¬¡\nqueryVotes Params:\nproposalId: type: uint256 desc: ææ¡ˆID Returns:\nvotes: type: uint256 desc: å½“å‰æ‰€è·ç¥¨æ•°ï¼Œå½“çŠ¶æ€ä¸ºæœªå¯åŠ¨æ—¶ï¼Œåº”ä¸º0 Desc: æŸ¥è¯¢å·²ç»è·å–çš„ç¥¨æ•°\ncheck Params:\nproposalId: type: uint256 desc: ææ¡ˆID Returns:\nstatus: type: string desc: æ£€ç¥¨çŠ¶æ€ï¼š\u0026ldquo;success\u0026rdquo; or \u0026ldquo;error\u0026rdquo;ï¼Œerroréœ€ç»™å‡ºåŸå›  Desc: å¯åŠ¨æ£€ç¥¨\nqueryPresident Returns: president: type: string desc: ç«é€‰æˆåŠŸçš„å€™é€‰äºº Desc: æŸ¥è¯¢å­¦ç”Ÿä¼šä¸»å¸­ä¿¡æ¯ queryCandidate Params: proposalId: type: uint256 desc: ææ¡ˆID Returns: candidate: type: string desc: ææ¡ˆå€™é€‰äººä¿¡æ¯ Desc: æŸ¥è¯¢ææ¡ˆå€™é€‰äººä¿¡æ¯ åˆçº¦è®¾è®¡ SafeMath å¯æä¾›ã€‚\nsolidity Copy // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.0; contract campaign{ // ä¸º uint256 ç±»å‹ä½¿ç”¨ SafeMath åº“ using SafeMath for uint256; // owner è´¦æˆ· address _owner; // å­¦ç”Ÿä¼šä¸»å¸­ string _president; // ææ¡ˆå€™é€‰äºº mapping(uint256 =\u0026gt; string) _candidate; // ææ¡ˆç¥¨æ•° mapping(uint256 =\u0026gt; uint256) _votes; // ç¥¨æ•°é˜ˆå€¼ uint256 _votesTarget; // ææ¡ˆID uint256 _proposalId; // ææ¡ˆçŠ¶æ€ ä¸ºäº†å‡å°‘ gas è´¹æ¶ˆè€—ï¼Œä½¿ç”¨uint256ç±»å‹è¿›è¡ŒçŠ¶æ€è®°å½•ï¼Œå¹¶é€šè¿‡mappingæ¥æä¾›çŠ¶æ€æ˜ å°„ mapping(uint256 =\u0026gt; uint256) proposalStatus; mapping(uint256 =\u0026gt; string) pstatus; // æŠ•ç¥¨è€…é›†åˆ mapping(uint256 =\u0026gt; mapping(address =\u0026gt; bool)) voted; /* * åˆå§‹åŒ–å‡½æ•° */ constructor(address owner){ _owner = owner; // åˆå§‹åŒ–ææ¡ˆçŠ¶æ€æ˜ å°„ pstatus[0] = \u0026#34;stoped\u0026#34;; pstatus[1] = \u0026#34;voting\u0026#34;; pstatus[2] = \u0026#34;passed\u0026#34;; pstatus[3] = \u0026#34;completed\u0026#34;; } /* * å¯åŠ¨ç«é€‰ææ¡ˆ theSender() æ–¹æ³•éå¿…é¡»ï¼Œç­‰åŒäº msg.sender; */ function propose(string memory candidate, uint256 target) public returns(uint256 proposalId){ // éªŒè¯èº«ä»½ require(theSender() == _owner, \u0026#34;error: No permission\u0026#34;); // éªŒè¯ææ¡ˆçŠ¶æ€ require(proposalStatus[_proposalId] == 0, \u0026#34;error: The proposal is not stoped status\u0026#34;); // è®¾ç½®å€™é€‰äºº _candidate[_proposalId] = candidate; // è®¾ç½®ç¥¨æ•°é˜ˆå€¼ _votesTarget = target; // è®¾ç½®ææ¡ˆçŠ¶æ€ proposalStatus[_proposalId] = 1; return _proposalId; } /* * æŸ¥è¯¢ææ¡ˆçŠ¶æ€ */ function queryProposal(uint256 proposalId) public view returns(string memory status){ return pstatus[proposalStatus[proposalId]]; } /* * æŠ•ç¥¨ */ function vote(uint256 proposalId) public returns(string memory status){ // éªŒè¯ææ¡ˆçŠ¶æ€ require(proposalStatus[proposalId] == 1, \u0026#34;error: The proposal is not voteable\u0026#34;); // éªŒè¯æ˜¯å¦å·²æŠ•ç¥¨ require(voted[proposalId][theSender()] == false, \u0026#34;error: Each person can only vote once\u0026#34;); // å¢åŠ å·²è·å–çš„ç¥¨æ•° _votes[proposalId] = _votes[proposalId].add(1); // é¿å…é‡å¤æŠ•ç¥¨ voted[proposalId][theSender()] = true; // æ˜¯å¦è¾¾åˆ°ç¥¨æ•°é˜ˆå€¼ if (_votes[proposalId] \u0026gt;= _votesTarget){ proposalStatus[proposalId] = 2; } return \u0026#34;vote successfuly\u0026#34;; } /* * æŸ¥è¯¢ææ¡ˆè·å–çš„ç¥¨æ•° */ function queryVotes(uint256 proposalId) public view returns(uint256 votes){ return _votes[proposalId]; } /* * æ£€ç¥¨ */ function check(uint256 proposalId) public returns(string memory status){ // éªŒè¯ææ¡ˆçŠ¶æ€ require(proposalStatus[proposalId] == 2, \u0026#34;error: The proposal is not eligible for wicket\u0026#34;); // éªŒè¯è°ƒç”¨è€…èº«ä»½ require(theSender() == _owner, \u0026#34;error: No permission\u0026#34;); // ä¿®æ”¹ææ¡ˆçŠ¶æ€ proposalStatus[proposalId] = 3; // ä¿®æ”¹å­¦ç”Ÿä¼šä¸»å¸­ä¿¡æ¯ _president = _candidate[proposalId]; // ä¸ºä¸‹ä¸€æ¬¡å‘èµ·ææ¡ˆåšå‡†å¤‡ _proposalId = _proposalId.add(1); return \u0026#34;check successfuly, the proposal will be take effect\u0026#34;; } /* * æŸ¥è¯¢å­¦ç”Ÿä¼šä¸»å¸­ä¿¡æ¯ */ function queryPresident() public view returns(string memory president){ return _president; } /* * æŸ¥è¯¢ææ¡ˆçš„å€™é€‰äººä¿¡æ¯ */ function queryCandidate(uint256 proposalId) public view returns(string memory candidate){ return _candidate[proposalId]; } /* * è¿”å›æ­¤æ¬¡è°ƒç”¨è€… */ function theSender() private view returns(address){ return msg.sender; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring \u0026#39;a\u0026#39; not being zero, but the // benefit is lost if \u0026#39;b\u0026#39; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c \u0026#43; a % b); // There is no case in which this doesn\u0026#39;t hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026lt;= a); uint256 c = a - b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a \u0026#43; b; require(c \u0026gt;= a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.0; contract campaign{ // ä¸º uint256 ç±»å‹ä½¿ç”¨ SafeMath åº“ using SafeMath for uint256; // owner è´¦æˆ· address _owner; // å­¦ç”Ÿä¼šä¸»å¸­ string _president; // ææ¡ˆå€™é€‰äºº mapping(uint256 =\u0026gt; string) _candidate; // ææ¡ˆç¥¨æ•° mapping(uint256 =\u0026gt; uint256) _votes; // ç¥¨æ•°é˜ˆå€¼ uint256 _votesTarget; // ææ¡ˆID uint256 _proposalId; // ææ¡ˆçŠ¶æ€ ä¸ºäº†å‡å°‘ gas è´¹æ¶ˆè€—ï¼Œä½¿ç”¨uint256ç±»å‹è¿›è¡ŒçŠ¶æ€è®°å½•ï¼Œå¹¶é€šè¿‡mappingæ¥æä¾›çŠ¶æ€æ˜ å°„ mapping(uint256 =\u0026gt; uint256) proposalStatus; mapping(uint256 =\u0026gt; string) pstatus; // æŠ•ç¥¨è€…é›†åˆ mapping(uint256 =\u0026gt; mapping(address =\u0026gt; bool)) voted; /* * åˆå§‹åŒ–å‡½æ•° */ constructor(address owner){ _owner = owner; // åˆå§‹åŒ–ææ¡ˆçŠ¶æ€æ˜ å°„ pstatus[0] = \u0026#34;stoped\u0026#34;; pstatus[1] = \u0026#34;voting\u0026#34;; pstatus[2] = \u0026#34;passed\u0026#34;; pstatus[3] = \u0026#34;completed\u0026#34;; } /* * å¯åŠ¨ç«é€‰ææ¡ˆ theSender() æ–¹æ³•éå¿…é¡»ï¼Œç­‰åŒäº msg.sender; */ function propose(string memory candidate, uint256 target) public returns(uint256 proposalId){ // éªŒè¯èº«ä»½ require(theSender() == _owner, \u0026#34;error: No permission\u0026#34;); // éªŒè¯ææ¡ˆçŠ¶æ€ require(proposalStatus[_proposalId] == 0, \u0026#34;error: The proposal is not stoped status\u0026#34;); // è®¾ç½®å€™é€‰äºº _candidate[_proposalId] = candidate; // è®¾ç½®ç¥¨æ•°é˜ˆå€¼ _votesTarget = target; // è®¾ç½®ææ¡ˆçŠ¶æ€ proposalStatus[_proposalId] = 1; return _proposalId; } /* * æŸ¥è¯¢ææ¡ˆçŠ¶æ€ */ function queryProposal(uint256 proposalId) public view returns(string memory status){ return pstatus[proposalStatus[proposalId]]; } /* * æŠ•ç¥¨ */ function vote(uint256 proposalId) public returns(string memory status){ // éªŒè¯ææ¡ˆçŠ¶æ€ require(proposalStatus[proposalId] == 1, \u0026#34;error: The proposal is not voteable\u0026#34;); // éªŒè¯æ˜¯å¦å·²æŠ•ç¥¨ require(voted[proposalId][theSender()] == false, \u0026#34;error: Each person can only vote once\u0026#34;); // å¢åŠ å·²è·å–çš„ç¥¨æ•° _votes[proposalId] = _votes[proposalId].add(1); // é¿å…é‡å¤æŠ•ç¥¨ voted[proposalId][theSender()] = true; // æ˜¯å¦è¾¾åˆ°ç¥¨æ•°é˜ˆå€¼ if (_votes[proposalId] \u0026gt;= _votesTarget){ proposalStatus[proposalId] = 2; } return \u0026#34;vote successfuly\u0026#34;; } /* * æŸ¥è¯¢ææ¡ˆè·å–çš„ç¥¨æ•° */ function queryVotes(uint256 proposalId) public view returns(uint256 votes){ return _votes[proposalId]; } /* * æ£€ç¥¨ */ function check(uint256 proposalId) public returns(string memory status){ // éªŒè¯ææ¡ˆçŠ¶æ€ require(proposalStatus[proposalId] == 2, \u0026#34;error: The proposal is not eligible for wicket\u0026#34;); // éªŒè¯è°ƒç”¨è€…èº«ä»½ require(theSender() == _owner, \u0026#34;error: No permission\u0026#34;); // ä¿®æ”¹ææ¡ˆçŠ¶æ€ proposalStatus[proposalId] = 3; // ä¿®æ”¹å­¦ç”Ÿä¼šä¸»å¸­ä¿¡æ¯ _president = _candidate[proposalId]; // ä¸ºä¸‹ä¸€æ¬¡å‘èµ·ææ¡ˆåšå‡†å¤‡ _proposalId = _proposalId.add(1); return \u0026#34;check successfuly, the proposal will be take effect\u0026#34;; } /* * æŸ¥è¯¢å­¦ç”Ÿä¼šä¸»å¸­ä¿¡æ¯ */ function queryPresident() public view returns(string memory president){ return _president; } /* * æŸ¥è¯¢ææ¡ˆçš„å€™é€‰äººä¿¡æ¯ */ function queryCandidate(uint256 proposalId) public view returns(string memory candidate){ return _candidate[proposalId]; } /* * è¿”å›æ­¤æ¬¡è°ƒç”¨è€… */ function theSender() private view returns(address){ return msg.sender; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring \u0026#39;a\u0026#39; not being zero, but the // benefit is lost if \u0026#39;b\u0026#39; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn\u0026#39;t hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026lt;= a); uint256 c = a - b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c \u0026gt;= a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } åˆçº¦éƒ¨ç½² ç¼–è¯‘ solc --abi --bin ./campaign.sol -o build\néƒ¨ç½² é€šè¿‡ Java SDK åœ¨ç™¾åº¦è¶…çº§é“¾å¼€æ”¾ç½‘ç»œè¿›è¡Œéƒ¨ç½²ã€‚\nSDKä½¿ç”¨æ–‡æ¡£ï¼šJava SDKæ¥å…¥æŒ‡å—\nè·å–SDK xml Copy \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baidu.xuper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xuper-java-sdk\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baidu.xuper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xuper-java-sdk\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; éƒ¨ç½²åˆçº¦ java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.AddressTrans; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); AddressTrans owner = AddressTrans.xChainToEvmAddress(account.getAddress()); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); // å¼€æ”¾ç½‘ç»œå·¥ä½œå°æ³¨å†Œçš„åˆçº¦è´¦æˆ· String contractAccount = \u0026#34;\u0026#34;; account.setContractAccount(contractAccount); try { // åˆçº¦ç¼–è¯‘æ–‡ä»¶ byte[] abi = Files.readAllBytes(Paths.get(\u0026#34;./build/campaign.abi\u0026#34;)); byte[] bin = Files.readAllBytes(Paths.get(\u0026#34;./build/campaign.bin\u0026#34;)); Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;owner\u0026#34;, owner.getAddr()); Transaction tx = client.deployEVMContract(account,bin,abi,\u0026#34;campaign\u0026#34;, params); System.out.println(tx.getContractResponse().getBodyStr()); } catch (IOException e) { e.printStackTrace(); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.AddressTrans; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); AddressTrans owner = AddressTrans.xChainToEvmAddress(account.getAddress()); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); // å¼€æ”¾ç½‘ç»œå·¥ä½œå°æ³¨å†Œçš„åˆçº¦è´¦æˆ· String contractAccount = \u0026#34;\u0026#34;; account.setContractAccount(contractAccount); try { // åˆçº¦ç¼–è¯‘æ–‡ä»¶ byte[] abi = Files.readAllBytes(Paths.get(\u0026#34;./build/campaign.abi\u0026#34;)); byte[] bin = Files.readAllBytes(Paths.get(\u0026#34;./build/campaign.bin\u0026#34;)); Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;owner\u0026#34;, owner.getAddr()); Transaction tx = client.deployEVMContract(account,bin,abi,\u0026#34;campaign\u0026#34;, params); System.out.println(tx.getContractResponse().getBodyStr()); } catch (IOException e) { e.printStackTrace(); } } } åˆçº¦è°ƒç”¨ å‘èµ·ææ¡ˆ java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;propose\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;candidate\u0026#34;, \u0026#34;alice\u0026#34;); params.put(\u0026#34;target\u0026#34;, \u0026#34;2\u0026#34;); Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;proposalId\u0026#34;:\u0026#34;0\u0026#34;}] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;propose\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;candidate\u0026#34;, \u0026#34;alice\u0026#34;); params.put(\u0026#34;target\u0026#34;, \u0026#34;2\u0026#34;); Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;proposalId\u0026#34;:\u0026#34;0\u0026#34;}] æŸ¥è¯¢ææ¡ˆçŠ¶æ€ java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryProposal\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.queryEVMContract(account,contract, method, params); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;status\u0026#34;:\u0026#34;voting\u0026#34;}] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryProposal\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.queryEVMContract(account,contract, method, params); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;status\u0026#34;:\u0026#34;voting\u0026#34;}] æŠ•ç¥¨ java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); Account account2 = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;vote\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); // æŠ•ä¸¤ç¥¨ Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account vote res: \u0026#34; \u0026#43; tx.getContractResponse().getBodyStr()); // é‡å¤æŠ•ç¥¨ Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account vote res: \u0026#34; \u0026#43; tx.getContractResponse().getBodyStr()); Transaction tx2 = client.invokeEVMContract(account2,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account2 vote res: \u0026#34; \u0026#43; tx2.getContractResponse().getBodyStr()); // éæŠ•ç¥¨çŠ¶æ€ä¸‹æŠ•ç¥¨ Transaction tx2 = client.invokeEVMContract(account2,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account2 vote res: \u0026#34; \u0026#43; tx2.getContractResponse().getBodyStr()); } } // output account vote res: [{\u0026#34;status\u0026#34;:\u0026#34;vote successfuly\u0026#34;}] \u0026#39;error: Each person can only vote once\u0026#39; account2 vote res: [{\u0026#34;status\u0026#34;:\u0026#34;vote successfuly\u0026#34;}] \u0026#39;error: The proposal is not voteable\u0026#39; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); Account account2 = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;vote\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); // æŠ•ä¸¤ç¥¨ Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account vote res: \u0026#34; + tx.getContractResponse().getBodyStr()); // é‡å¤æŠ•ç¥¨ Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account vote res: \u0026#34; + tx.getContractResponse().getBodyStr()); Transaction tx2 = client.invokeEVMContract(account2,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account2 vote res: \u0026#34; + tx2.getContractResponse().getBodyStr()); // éæŠ•ç¥¨çŠ¶æ€ä¸‹æŠ•ç¥¨ Transaction tx2 = client.invokeEVMContract(account2,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account2 vote res: \u0026#34; + tx2.getContractResponse().getBodyStr()); } } // output account vote res: [{\u0026#34;status\u0026#34;:\u0026#34;vote successfuly\u0026#34;}] \u0026#39;error: Each person can only vote once\u0026#39; account2 vote res: [{\u0026#34;status\u0026#34;:\u0026#34;vote successfuly\u0026#34;}] \u0026#39;error: The proposal is not voteable\u0026#39; æŸ¥è¯¢å·²ç»è·å–çš„ç¥¨æ•° java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryVotes\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.queryEVMContract(account,contract, method, params); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;votes\u0026#34;:\u0026#34;2\u0026#34;}] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryVotes\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.queryEVMContract(account,contract, method, params); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;votes\u0026#34;:\u0026#34;2\u0026#34;}] æ£€ç¥¨ java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;check\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;status\u0026#34;:\u0026#34;check successfuly, the proposal will be take effect\u0026#34;}] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;check\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;status\u0026#34;:\u0026#34;check successfuly, the proposal will be take effect\u0026#34;}] æŸ¥è¯¢å­¦ç”Ÿä¼šä¸»å¸­ä¿¡æ¯ java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryPresident\u0026#34;; Transaction tx = client.queryEVMContract(account,contract, method, null); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;president\u0026#34;:\u0026#34;alice\u0026#34;}] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryPresident\u0026#34;; Transaction tx = client.queryEVMContract(account,contract, method, null); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;president\u0026#34;:\u0026#34;alice\u0026#34;}] æŸ¥è¯¢å€™é€‰äººä¿¡æ¯ java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryCandidate\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.queryEVMContract(account,contract, method, params); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;candidate\u0026#34;:\u0026#34;alice\u0026#34;}] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryCandidate\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.queryEVMContract(account,contract, method, params); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;candidate\u0026#34;:\u0026#34;alice\u0026#34;}] åˆ›å»ºæ–°ä¸€è½®ææ¡ˆ java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;propose\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;candidate\u0026#34;, \u0026#34;bob\u0026#34;); params.put(\u0026#34;target\u0026#34;, \u0026#34;3\u0026#34;); Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;proposalId\u0026#34;:\u0026#34;1\u0026#34;}] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // è®¾ç½®èƒŒä¹¦æœåŠ¡ Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;å¼€æ”¾ç½‘ç»œç§é’¥ç›®å½•\u0026#34;,\u0026#34;å®‰å…¨ç \u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;propose\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;candidate\u0026#34;, \u0026#34;bob\u0026#34;); params.put(\u0026#34;target\u0026#34;, \u0026#34;3\u0026#34;); Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;proposalId\u0026#34;:\u0026#34;1\u0026#34;}] ","date":"2022-09-28T00:00:00Z","image":"https://superlitian.github.io/p/campaign/header_hud30b7d800d6a863e0643d87b3a87316b_148688_120x120_fill_q75_box_smart1.jpg","permalink":"https://superlitian.github.io/p/campaign/","title":"ææ¡ˆæŠ•ç¥¨åˆçº¦"}]
[{"content":"输入描述 输入一行，代表要计算的字符串，非空，长度小于5000。\n输出描述 输出一个整数，表示输入字符串最后一个单词的长度。\n示例 输入 hello world\n输出 5\n说明 最后一个单词为world，长度为5\ncode go Copy package easy import \u0026#34;strings\u0026#34; func HJ1(str string) int { arr := strings.Split(str, \u0026#34; \u0026#34;) return len(arr[len(arr)-1]) } 1 2 3 4 5 6 7 8 package easy import \u0026#34;strings\u0026#34; func HJ1(str string) int { arr := strings.Split(str, \u0026#34; \u0026#34;) return len(arr[len(arr)-1]) } ","date":"2023-01-17T00:00:00Z","permalink":"https://superlitian.github.io/p/hj1/","title":"HJ1 字符串最后一个单词的长度"},{"content":"数据范围 1≤n≤1000\n输入描述 第一行输入一个由字母、数字和空格组成的字符串，第二行输入一个字符（保证该字符不为空格）。\n输出描述 输出输入字符串中含有该字符的个数。（不区分大小写字母）\n示例 输入 ABCabc A\n输出 2\ncode go Copy package easy import \u0026#34;strings\u0026#34; func HJ2(str, target string) int { s := strings.ToLower(str) tar := strings.ToLower(target) count := 0 for _, v := range s { if string(v) == tar { count\u0026#43;\u0026#43; } } return count } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package easy import \u0026#34;strings\u0026#34; func HJ2(str, target string) int { s := strings.ToLower(str) tar := strings.ToLower(target) count := 0 for _, v := range s { if string(v) == tar { count++ } } return count } ","date":"2023-01-17T00:00:00Z","permalink":"https://superlitian.github.io/p/hj2/","title":"HJ2 计算某字符出现次数"},{"content":"输入描述 连续输入字符串(每个字符串长度小于等于100)\n输出描述 依次输出所有分割后的长度为8的新字符串\n示例 输入 abc\n输出 abc00000\ncode go Copy package easy import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; \u0026#34;strings\u0026#34; ) func HJ4(str string) string { if str == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34; } var build strings.Builder length := int(math.Ceil(float64(len(str)) / 8.0)) arr := make([]string, length) // len(str) \u0026lt;= 8 if len(str) \u0026lt;= 8 { n := 8 - len(str) build.WriteString(str) for n \u0026gt; 0 { build.WriteString(\u0026#34;0\u0026#34;) n-- } return build.String() } p1 := 0 index := 0 p2 := 7 for p1 \u0026lt; len(str) { build.WriteString(string(str[p1])) if p1 == p2 { arr[index] = build.String() build.Reset() index\u0026#43;\u0026#43; p2 = p1 \u0026#43; 8 } p1\u0026#43;\u0026#43; } if p1 \u0026lt; p2 { c := p2 - p1 for c \u0026gt;= 0 { build.WriteString(\u0026#34;0\u0026#34;) c-- } arr[index] = build.String() } res := \u0026#34;\u0026#34; for _, v := range arr { res \u0026#43;= fmt.Sprintf(\u0026#34;%s\\n\u0026#34;, v) } fmt.Println(arr) return res } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package easy import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; \u0026#34;strings\u0026#34; ) func HJ4(str string) string { if str == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34; } var build strings.Builder length := int(math.Ceil(float64(len(str)) / 8.0)) arr := make([]string, length) // len(str) \u0026lt;= 8 if len(str) \u0026lt;= 8 { n := 8 - len(str) build.WriteString(str) for n \u0026gt; 0 { build.WriteString(\u0026#34;0\u0026#34;) n-- } return build.String() } p1 := 0 index := 0 p2 := 7 for p1 \u0026lt; len(str) { build.WriteString(string(str[p1])) if p1 == p2 { arr[index] = build.String() build.Reset() index++ p2 = p1 + 8 } p1++ } if p1 \u0026lt; p2 { c := p2 - p1 for c \u0026gt;= 0 { build.WriteString(\u0026#34;0\u0026#34;) c-- } arr[index] = build.String() } res := \u0026#34;\u0026#34; for _, v := range arr { res += fmt.Sprintf(\u0026#34;%s\\n\u0026#34;, v) } fmt.Println(arr) return res } ","date":"2023-01-17T00:00:00Z","permalink":"https://superlitian.github.io/p/hj4/","title":"HJ4 字符串分隔"},{"content":"数据范围 $$ 1≤n≤2^{31}−1 $$\n输入描述 输入一个十六进制的数值字符串。\n输出描述 输出该数值的十进制字符串。不同组的测试用例用\\n隔开。\n示例 输入 0e\n输出 14\n说明 最后一个单词为nowcoder，长度为8\ncode go Copy package easy import ( \u0026#34;strconv\u0026#34; ) func HJ5(str string) int { res, err := strconv.ParseInt(str, 16, 32) if err != nil { panic(err) } return int(res) } 1 2 3 4 5 6 7 8 9 10 11 12 13 package easy import ( \u0026#34;strconv\u0026#34; ) func HJ5(str string) int { res, err := strconv.ParseInt(str, 16, 32) if err != nil { panic(err) } return int(res) } ","date":"2023-01-17T00:00:00Z","permalink":"https://superlitian.github.io/p/hj5/","title":"HJ5 进制转换"},{"content":"🌏️ 实用的工具类网站 所有网站全部为免费，部分网站可能需要翻墙\n🇺🇸 removebg 介绍：删除图像背景 官网：https://www.remove.bg/zh 🇨🇳 天空之城 介绍：全球航拍爱好者和专业摄影师的作品社区 官网：https://www.skypixel.com/ 🇨🇳 幽灵疾步 介绍：专一的英雄联盟内容聚合 官网：https://www.ghostoact.com/ 🇩🇪 CloudConvert 介绍：图片文件转换，可以转换为icon等 官网：https://cloudconvert.com/ 🇨🇳 m3ub downloader 介绍：m3u8 视频在线提取工具 官网：http://blog.luckly-mjw.cn/tool-show/m3u8-downloader/index.html 🇺🇸 Zamzar 介绍：视频转换器、音频转换器、图像转换器、电子书转换器 官网：https://www.zamzar.com/ 🇨🇳 CatNet 介绍：代理平台 官网：https://dash.catnet.uk/ 🇨🇳 EmojiALL 介绍：Emoji 词典 官网：https://www.emojiall.com/ ","date":"2022-10-12T00:00:00Z","permalink":"https://superlitian.github.io/p/site/","title":"🌏️ 实用的工具类网站"},{"content":"🌼 开源代码贡献指南 🌿 Fork 代码 访问自己想要贡献的代码库，然后fork代码到自己的代码仓库。 🪁 Clone 代码到本地 假设fork完之后的代码仓库路径为 🔗 git@github.com:uaanaa/xuperchain.git\nshell Copy git clone git@github.com:uaanaa/xuperchain.git 1 git clone git@github.com:uaanaa/xuperchain.git 克隆到本地之后设置一个 upstream 的 remote 地址，方便我们同步原始仓库地址的更新\nshell Copy git remote add upstream https://github.com/xuperchain/xuperchain.git 1 git remote add upstream https://github.com/xuperchain/xuperchain.git ♎ 同步代码\u0026amp;建立分支 每次要提交PR的时候都要 新建 一个分支，这样可以同时开发多个feature，分支基于 upstream 的 master 建立\nshell Copy # 拉取上游的最新代码 git fetch upstream # 建立新分支 git checkout -b new_feature upstream/master 1 2 3 4 5 # 拉取上游的最新代码 git fetch upstream # 建立新分支 git checkout -b new_feature upstream/master 🟢 提交代码 当我们的代码写完之后就可以提交了，注意我们这里提交的remote是 origin，也就是自己的代码仓库\nshell Copy git push origin new_feature Counting objects: 3, done. Delta compression using up to 2 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 286 bytes | 286.00 KiB/s, done. Total 3 (delta 2), reused 0 (delta 0) remote: Resolving deltas: 100% (2/2), completed with 2 local objects. remote: remote: Create a pull request for \u0026#39;new_feature\u0026#39; on GitHub by visiting: remote: https://github.com/uaanaa/xuperunion/pull/new/new_feature remote: To https://github.com/uaanaa/xuperunion.git * [new branch] new_feature -\u0026gt; new_feature 1 2 3 4 5 6 7 8 9 10 11 12 13 git push origin new_feature Counting objects: 3, done. Delta compression using up to 2 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 286 bytes | 286.00 KiB/s, done. Total 3 (delta 2), reused 0 (delta 0) remote: Resolving deltas: 100% (2/2), completed with 2 local objects. remote: remote: Create a pull request for \u0026#39;new_feature\u0026#39; on GitHub by visiting: remote: https://github.com/uaanaa/xuperunion/pull/new/new_feature remote: To https://github.com/uaanaa/xuperunion.git * [new branch] new_feature -\u0026gt; new_feature 🇨🇳 创建PR 提交完之后，一般有个类似 https://github.com/uaanaa/xuperunion/pull/new/new_feature 这样的地址，在浏览器打开这个地址就跳转到创建PR的页面进行提交即可。\n","date":"2022-10-12T00:00:00Z","permalink":"https://superlitian.github.io/p/pr/","title":"📃 开源代码贡献方法"},{"content":"🔴 git 检查大小写不敏感 今天需要将项目一个文件名首字母从小写改为大写，改好之后发现 git status 并没有检查到更改。\n🟡 原因 对于 windows 和 macOS 用户，每次 git clone 之后，都在该项目的 📁 .git/config 文件中设置了 core.ignorecase = true\n🟢 解决 在终端执行以下命令，将忽略大小写改为false\nshell Copy git config core.ignorecase false 1 git config core.ignorecase false ","date":"2022-10-12T00:00:00Z","permalink":"https://superlitian.github.io/p/git/","title":"🧰 git 忽略大小写问题"},{"content":"ERC20 solidity Copy // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.0; contract Cafe20{ using SafeMath for uint256; // creator address private _creator; // token name string private _name; // token symbol string private _symbol; // token totalSupply uint256 private _totalSupply; // address have how much token mapping (address =\u0026gt; uint256) private balances; // owner approve spender spend how much token mapping (address =\u0026gt; mapping (address =\u0026gt; uint256)) private allowances; constructor(string memory name_, string memory symbol_) public { _creator = theSender(); _name = name_; _symbol = symbol_; } /** * total tokens */ function totalSupply() public view returns (uint256) { return _totalSupply; } /** * mints tokens, only creator can call this function */ function mint(uint256 value) public returns (bool) { require(theSender() == _creator, \u0026#34;Cafe20: No permission\u0026#34;); _totalSupply = _totalSupply.add(value); balances[_creator] = balances[_creator].add(value); return true; } // when the token transfer, must be call this function event Transfer(address indexed _from, address indexed _to, uint256 _value); // when the approval, must be call this function event Approval(address indexed _owner, address indexed _spender, uint256 _value); /** * return this token\u0026#39;s name */ function name() public view returns (string memory) { return _name; } function creator() public view returns (address) { return _creator; } /** * return this token\u0026#39;s symbol */ function symbol() public view returns (string memory) { return _symbol; } /** * return this token\u0026#39;s number of decimal places */ function decimals() public view virtual returns (uint8) { return 5; } /* * return the sender\u0026#39;s balance */ function balance() public view returns (uint256 balance) { return balances[theSender()]; } /** * return the balance of this address */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } /** * transfer to address */ function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[theSender()] \u0026gt;= _value,\u0026#34;Cafe20: not enough balance\u0026#34;); require(_to != address(0), \u0026#34;Cafe20: can not to the zero address transfer\u0026#34;); balances[theSender()] = balances[theSender()].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(theSender(), _to, _value); return true; } /** * transfer from address to other address */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { if(theSender() == _from){ return transfer(_to, _value); } uint256 tokens = allowance(_from, theSender()); require(_from != address(0), \u0026#34;Cafe20: can not from the zero address transfer\u0026#34;); require(_to != address(0), \u0026#34;Cafe20: can not to the zero address transfer\u0026#34;); require(balances[_from] \u0026gt;= _value, \u0026#34;Cafe20: not enough tokens\u0026#34;); require(tokens \u0026gt;= _value, \u0026#34;Cafe20: the allowance not enough tokens\u0026#34;); // update balance balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); // update allowances allowances[_from][theSender()] = allowances[_from][theSender()].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * approve the spender for msg.sender */ function approve(address _spender, uint256 _value) public returns (bool success) { address _owner = theSender(); require(_spender != address(0), \u0026#34;Cafe20: can not approve the zero address\u0026#34;); require(balances[_owner] \u0026gt;= _value, \u0026#34;Cafe20: not enough tokens\u0026#34;); allowances[_owner][_spender] = allowances[_owner][_spender].add(_value); emit Approval(_owner, _spender, _value); return true; } /* * query the amount which _spender is still allowed to withdraw from _owner */ function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowances[_owner][_spender]; } /* * destroy the tokens */ function destroyTokens(uint256 _value) public returns (bool success) { require(balances[theSender()] \u0026gt;= _value, \u0026#34;Cafe20: not enough tokens\u0026#34;); balances[theSender()] = balances[theSender()].sub(_value); _totalSupply = _totalSupply.sub(_value); return true; } /* * msg.sender */ function theSender() private view returns (address) { return msg.sender; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring \u0026#39;a\u0026#39; not being zero, but the // benefit is lost if \u0026#39;b\u0026#39; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c \u0026#43; a % b); // There is no case in which this doesn\u0026#39;t hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026lt;= a); uint256 c = a - b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a \u0026#43; b; require(c \u0026gt;= a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.0; contract Cafe20{ using SafeMath for uint256; // creator address private _creator; // token name string private _name; // token symbol string private _symbol; // token totalSupply uint256 private _totalSupply; // address have how much token mapping (address =\u0026gt; uint256) private balances; // owner approve spender spend how much token mapping (address =\u0026gt; mapping (address =\u0026gt; uint256)) private allowances; constructor(string memory name_, string memory symbol_) public { _creator = theSender(); _name = name_; _symbol = symbol_; } /** * total tokens */ function totalSupply() public view returns (uint256) { return _totalSupply; } /** * mints tokens, only creator can call this function */ function mint(uint256 value) public returns (bool) { require(theSender() == _creator, \u0026#34;Cafe20: No permission\u0026#34;); _totalSupply = _totalSupply.add(value); balances[_creator] = balances[_creator].add(value); return true; } // when the token transfer, must be call this function event Transfer(address indexed _from, address indexed _to, uint256 _value); // when the approval, must be call this function event Approval(address indexed _owner, address indexed _spender, uint256 _value); /** * return this token\u0026#39;s name */ function name() public view returns (string memory) { return _name; } function creator() public view returns (address) { return _creator; } /** * return this token\u0026#39;s symbol */ function symbol() public view returns (string memory) { return _symbol; } /** * return this token\u0026#39;s number of decimal places */ function decimals() public view virtual returns (uint8) { return 5; } /* * return the sender\u0026#39;s balance */ function balance() public view returns (uint256 balance) { return balances[theSender()]; } /** * return the balance of this address */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } /** * transfer to address */ function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[theSender()] \u0026gt;= _value,\u0026#34;Cafe20: not enough balance\u0026#34;); require(_to != address(0), \u0026#34;Cafe20: can not to the zero address transfer\u0026#34;); balances[theSender()] = balances[theSender()].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(theSender(), _to, _value); return true; } /** * transfer from address to other address */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { if(theSender() == _from){ return transfer(_to, _value); } uint256 tokens = allowance(_from, theSender()); require(_from != address(0), \u0026#34;Cafe20: can not from the zero address transfer\u0026#34;); require(_to != address(0), \u0026#34;Cafe20: can not to the zero address transfer\u0026#34;); require(balances[_from] \u0026gt;= _value, \u0026#34;Cafe20: not enough tokens\u0026#34;); require(tokens \u0026gt;= _value, \u0026#34;Cafe20: the allowance not enough tokens\u0026#34;); // update balance balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); // update allowances allowances[_from][theSender()] = allowances[_from][theSender()].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * approve the spender for msg.sender */ function approve(address _spender, uint256 _value) public returns (bool success) { address _owner = theSender(); require(_spender != address(0), \u0026#34;Cafe20: can not approve the zero address\u0026#34;); require(balances[_owner] \u0026gt;= _value, \u0026#34;Cafe20: not enough tokens\u0026#34;); allowances[_owner][_spender] = allowances[_owner][_spender].add(_value); emit Approval(_owner, _spender, _value); return true; } /* * query the amount which _spender is still allowed to withdraw from _owner */ function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowances[_owner][_spender]; } /* * destroy the tokens */ function destroyTokens(uint256 _value) public returns (bool success) { require(balances[theSender()] \u0026gt;= _value, \u0026#34;Cafe20: not enough tokens\u0026#34;); balances[theSender()] = balances[theSender()].sub(_value); _totalSupply = _totalSupply.sub(_value); return true; } /* * msg.sender */ function theSender() private view returns (address) { return msg.sender; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring \u0026#39;a\u0026#39; not being zero, but the // benefit is lost if \u0026#39;b\u0026#39; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn\u0026#39;t hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026lt;= a); uint256 c = a - b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c \u0026gt;= a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } ","date":"2022-09-29T00:00:00Z","permalink":"https://superlitian.github.io/p/erc20/","title":"ERC20合约"},{"content":"ERC721 solidity Copy // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.10; interface IERC721Receiver{ function onERC721Received( address operator, address from, uint256 tokenId, bytes calldata data ) external returns (bytes4); } contract Cafe721 { using SafeMath for uint256; //creator address private contractCreator; // name string private _name; // symbol string private _symbol; // Token struct Cafe { address creator; address owner; address approved; bytes32 summary; string uri; } // all Cafe mapping (uint256 =\u0026gt; Cafe) allCafe; // cafe\u0026#39;s counts uint256 _totalCafe; // User struct User { uint256[] cafes; uint256 totalCafe; } // all user mapping (address =\u0026gt; User) allUser; // operator approvals mapping (address =\u0026gt; mapping (address =\u0026gt; bool)) operatorApprovals; constructor(string memory name_, string memory symbol_){ contractCreator = theSender(); _name = name_; _symbol = symbol_; } event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); /* * the address have how much tokens */ function balanceOf(address _owner) external view returns (uint256 balance) { return allUser[_owner].totalCafe; } function cafesOf(address _owner) external view returns (uint256[] memory cafes){ return allUser[_owner].cafes; } /* * the token\u0026#39;s owner */ function ownerOf(uint256 _tokenId) external view returns (address owner) { return allCafe[_tokenId].owner; } function creatorOf(uint256 _tokenId) external view returns (address creator) { return allCafe[_tokenId].creator; } // trans begin function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool success) { // checked token require(exists(_tokenId), \u0026#34;Cafe721: the cafe is not exists\u0026#34;); // checked addr require(zeroAddr(_from), \u0026#34;Cafe721: can not from the zero address\u0026#34;); require(zeroAddr(_to), \u0026#34;Cafe721: can not to the zero address\u0026#34;); // checked permission require(isApprovedOrOwner(_tokenId), \u0026#34;Cafe721: no permission\u0026#34;); // remove cafe remove(_from, _tokenId); // transfer cafe allCafe[_tokenId].owner = _to; allCafe[_tokenId].approved = address(0); // add cafe allUser[_to].cafes.push(_tokenId); allUser[_to].totalCafe = allUser[_to].totalCafe.add(1); emit Transfer(_from, _to, _tokenId); return true; } function safeTransferFrom(address _from, address _to, uint256 _tokenId) external virtual returns (bool success) { return safeTransferFrom(_from, _to, _tokenId, \u0026#34;\u0026#34;); } function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public virtual returns (bool success) { require(isApprovedOrOwner(_tokenId), \u0026#34;Cafe721: no permission\u0026#34;); transferFrom(_from, _to, _tokenId); require(checkOnERC721Received(_from, _to, _tokenId, _data), \u0026#34;Cafe721: transfer to non ERC721Receiver implementer\u0026#34;); return true; } // trans end function approve(address _approved, uint256 _tokenId) external returns (bool success) { require(allCafe[_tokenId].owner == theSender(), \u0026#34;Cafe721: no permission\u0026#34;); require(_approved != theSender(), \u0026#34;Cafe721: can not approved for owner\u0026#34;); allCafe[_tokenId].approved = _approved; emit Approval(theSender(), _approved, _tokenId); return true; } function setApprovalForAll(address _operator, bool _approved) external returns (bool success) { require(_operator != theSender(), \u0026#34;Cafe721: can not approved for owner\u0026#34;); operatorApprovals[theSender()][_operator] = _approved; emit ApprovalForAll(theSender(), _operator, _approved); return true; } function getApproved(uint256 _tokenId) private view returns(address) { return allCafe[_tokenId].approved; } function isApprovedForAll(address _owner, address _operator) public view returns (bool) { return operatorApprovals[_owner][_operator]; } function name() external view returns (string memory) { return _name; } function symbol() external view returns (string memory) { return _symbol; } function tokenURI(uint256 _tokenId) external view returns (string memory uri) { return allCafe[_tokenId].uri; } function tokenSummary(uint256 _tokenId) external view returns (bytes32 summary) { return allCafe[_tokenId].summary; } function totalSupply() external view returns (uint256 totalCafe) { return _totalCafe; } function exists(uint256 _tokenId) internal view returns (bool){ return allCafe[_tokenId].owner != address(0); } function zeroAddr(address addr) private pure returns (bool) { return addr != address(0); } function remove(address _from, uint256 _tokenId) private { uint[] storage cafes = allUser[_from].cafes; for (uint i = 0; i \u0026lt; cafes.length - 1; i\u0026#43;\u0026#43;){ if(cafes[i] == _tokenId){ cafes[i] = cafes[cafes.length \u0026#43; 1]; break; } } delete cafes[cafes.length - 1]; cafes.pop(); allUser[_from].cafes = cafes; allUser[_from].totalCafe = allUser[_from].totalCafe.sub(1); } /* * address owner; * address approved; * bytes32 summary; * string uri; */ function mint(uint256 _tokenId, bytes32 _summary, string memory _uri) external { require(allCafe[_tokenId].creator == address(0), \u0026#34;Cafe721: the cafe is exists.\u0026#34;); allCafe[_tokenId].creator = theSender(); allCafe[_tokenId].owner = theSender(); allCafe[_tokenId].approved = address(0); allCafe[_tokenId].summary = _summary; allCafe[_tokenId].uri = _uri; // User allUser[theSender()].cafes.push(_tokenId); allUser[theSender()].totalCafe = allUser[theSender()].totalCafe.add(1); _totalCafe = _totalCafe.add(1); } function isApprovedOrOwner(uint256 _tokenId) private view returns (bool) { require(exists(_tokenId), \u0026#34;Cafe721: the cafe is exists.\u0026#34;); return (theSender() == allCafe[_tokenId].owner || isApprovedForAll(allCafe[_tokenId].owner, theSender()) || getApproved(_tokenId) == theSender()); } function checkOnERC721Received(address from,address to,uint256 tokenId,bytes memory _data) private returns (bool) { if (to.code.length \u0026gt; 0) { try IERC721Receiver(to).onERC721Received(theSender(), from, tokenId, _data) returns (bytes4 retval) { return retval == IERC721Receiver.onERC721Received.selector; } catch (bytes memory reason) { if (reason.length == 0) { revert(\u0026#34;ERC721: transfer to non ERC721Receiver implementer\u0026#34;); } else { assembly { revert(add(32, reason), mload(reason)) } } } } else { return true; } } // destroyCafe function destroyCafe(uint256 _tokenId) external returns (bool success) { require(allCafe[_tokenId].owner == theSender(), \u0026#34;Cafe721: no premission\u0026#34;); remove(theSender(), _tokenId); delete allCafe[_tokenId]; _totalCafe = _totalCafe.sub(1); return true; } function theSender() internal view returns (address) { return msg.sender; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring \u0026#39;a\u0026#39; not being zero, but the // benefit is lost if \u0026#39;b\u0026#39; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c \u0026#43; a % b); // There is no case in which this doesn\u0026#39;t hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026lt;= a); uint256 c = a - b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a \u0026#43; b; require(c \u0026gt;= a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.10; interface IERC721Receiver{ function onERC721Received( address operator, address from, uint256 tokenId, bytes calldata data ) external returns (bytes4); } contract Cafe721 { using SafeMath for uint256; //creator address private contractCreator; // name string private _name; // symbol string private _symbol; // Token struct Cafe { address creator; address owner; address approved; bytes32 summary; string uri; } // all Cafe mapping (uint256 =\u0026gt; Cafe) allCafe; // cafe\u0026#39;s counts uint256 _totalCafe; // User struct User { uint256[] cafes; uint256 totalCafe; } // all user mapping (address =\u0026gt; User) allUser; // operator approvals mapping (address =\u0026gt; mapping (address =\u0026gt; bool)) operatorApprovals; constructor(string memory name_, string memory symbol_){ contractCreator = theSender(); _name = name_; _symbol = symbol_; } event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); /* * the address have how much tokens */ function balanceOf(address _owner) external view returns (uint256 balance) { return allUser[_owner].totalCafe; } function cafesOf(address _owner) external view returns (uint256[] memory cafes){ return allUser[_owner].cafes; } /* * the token\u0026#39;s owner */ function ownerOf(uint256 _tokenId) external view returns (address owner) { return allCafe[_tokenId].owner; } function creatorOf(uint256 _tokenId) external view returns (address creator) { return allCafe[_tokenId].creator; } // trans begin function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool success) { // checked token require(exists(_tokenId), \u0026#34;Cafe721: the cafe is not exists\u0026#34;); // checked addr require(zeroAddr(_from), \u0026#34;Cafe721: can not from the zero address\u0026#34;); require(zeroAddr(_to), \u0026#34;Cafe721: can not to the zero address\u0026#34;); // checked permission require(isApprovedOrOwner(_tokenId), \u0026#34;Cafe721: no permission\u0026#34;); // remove cafe remove(_from, _tokenId); // transfer cafe allCafe[_tokenId].owner = _to; allCafe[_tokenId].approved = address(0); // add cafe allUser[_to].cafes.push(_tokenId); allUser[_to].totalCafe = allUser[_to].totalCafe.add(1); emit Transfer(_from, _to, _tokenId); return true; } function safeTransferFrom(address _from, address _to, uint256 _tokenId) external virtual returns (bool success) { return safeTransferFrom(_from, _to, _tokenId, \u0026#34;\u0026#34;); } function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public virtual returns (bool success) { require(isApprovedOrOwner(_tokenId), \u0026#34;Cafe721: no permission\u0026#34;); transferFrom(_from, _to, _tokenId); require(checkOnERC721Received(_from, _to, _tokenId, _data), \u0026#34;Cafe721: transfer to non ERC721Receiver implementer\u0026#34;); return true; } // trans end function approve(address _approved, uint256 _tokenId) external returns (bool success) { require(allCafe[_tokenId].owner == theSender(), \u0026#34;Cafe721: no permission\u0026#34;); require(_approved != theSender(), \u0026#34;Cafe721: can not approved for owner\u0026#34;); allCafe[_tokenId].approved = _approved; emit Approval(theSender(), _approved, _tokenId); return true; } function setApprovalForAll(address _operator, bool _approved) external returns (bool success) { require(_operator != theSender(), \u0026#34;Cafe721: can not approved for owner\u0026#34;); operatorApprovals[theSender()][_operator] = _approved; emit ApprovalForAll(theSender(), _operator, _approved); return true; } function getApproved(uint256 _tokenId) private view returns(address) { return allCafe[_tokenId].approved; } function isApprovedForAll(address _owner, address _operator) public view returns (bool) { return operatorApprovals[_owner][_operator]; } function name() external view returns (string memory) { return _name; } function symbol() external view returns (string memory) { return _symbol; } function tokenURI(uint256 _tokenId) external view returns (string memory uri) { return allCafe[_tokenId].uri; } function tokenSummary(uint256 _tokenId) external view returns (bytes32 summary) { return allCafe[_tokenId].summary; } function totalSupply() external view returns (uint256 totalCafe) { return _totalCafe; } function exists(uint256 _tokenId) internal view returns (bool){ return allCafe[_tokenId].owner != address(0); } function zeroAddr(address addr) private pure returns (bool) { return addr != address(0); } function remove(address _from, uint256 _tokenId) private { uint[] storage cafes = allUser[_from].cafes; for (uint i = 0; i \u0026lt; cafes.length - 1; i++){ if(cafes[i] == _tokenId){ cafes[i] = cafes[cafes.length + 1]; break; } } delete cafes[cafes.length - 1]; cafes.pop(); allUser[_from].cafes = cafes; allUser[_from].totalCafe = allUser[_from].totalCafe.sub(1); } /* * address owner; * address approved; * bytes32 summary; * string uri; */ function mint(uint256 _tokenId, bytes32 _summary, string memory _uri) external { require(allCafe[_tokenId].creator == address(0), \u0026#34;Cafe721: the cafe is exists.\u0026#34;); allCafe[_tokenId].creator = theSender(); allCafe[_tokenId].owner = theSender(); allCafe[_tokenId].approved = address(0); allCafe[_tokenId].summary = _summary; allCafe[_tokenId].uri = _uri; // User allUser[theSender()].cafes.push(_tokenId); allUser[theSender()].totalCafe = allUser[theSender()].totalCafe.add(1); _totalCafe = _totalCafe.add(1); } function isApprovedOrOwner(uint256 _tokenId) private view returns (bool) { require(exists(_tokenId), \u0026#34;Cafe721: the cafe is exists.\u0026#34;); return (theSender() == allCafe[_tokenId].owner || isApprovedForAll(allCafe[_tokenId].owner, theSender()) || getApproved(_tokenId) == theSender()); } function checkOnERC721Received(address from,address to,uint256 tokenId,bytes memory _data) private returns (bool) { if (to.code.length \u0026gt; 0) { try IERC721Receiver(to).onERC721Received(theSender(), from, tokenId, _data) returns (bytes4 retval) { return retval == IERC721Receiver.onERC721Received.selector; } catch (bytes memory reason) { if (reason.length == 0) { revert(\u0026#34;ERC721: transfer to non ERC721Receiver implementer\u0026#34;); } else { assembly { revert(add(32, reason), mload(reason)) } } } } else { return true; } } // destroyCafe function destroyCafe(uint256 _tokenId) external returns (bool success) { require(allCafe[_tokenId].owner == theSender(), \u0026#34;Cafe721: no premission\u0026#34;); remove(theSender(), _tokenId); delete allCafe[_tokenId]; _totalCafe = _totalCafe.sub(1); return true; } function theSender() internal view returns (address) { return msg.sender; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring \u0026#39;a\u0026#39; not being zero, but the // benefit is lost if \u0026#39;b\u0026#39; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn\u0026#39;t hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026lt;= a); uint256 c = a - b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c \u0026gt;= a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } ","date":"2022-09-29T00:00:00Z","permalink":"https://superlitian.github.io/p/erc721/","title":"ERC721合约"},{"content":"两种方法解决 将value 转为 16进制或base64，服务端单独做一层解码\ngo Copy bt := []byte{230,136} hexStr := hex.EncodeToString(bt) args := map[string]string{} args[\u0026#34;a\u0026#34;] = hexStr fmt.Printf(\u0026#34;a %v\\n\u0026#34;,bt) println(\u0026#34;len a\u0026#34;, len(bt)) input, err := json.Marshal(args) if err != nil { fmt.Println(err) } var decodeArgs map[string]string err =json.Unmarshal(input, \u0026amp;decodeArgs) if err != nil { return } b, err := hex.DecodeString(decodeArgs[\u0026#34;a\u0026#34;]) if err != nil { return } fmt.Println(\u0026#34;b\u0026#34;, b) fmt.Println(\u0026#34;len b\u0026#34;, len(b)) // output a [230 136] len a 2 b [230 136] len b 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 bt := []byte{230,136} hexStr := hex.EncodeToString(bt) args := map[string]string{} args[\u0026#34;a\u0026#34;] = hexStr fmt.Printf(\u0026#34;a %v\\n\u0026#34;,bt) println(\u0026#34;len a\u0026#34;, len(bt)) input, err := json.Marshal(args) if err != nil { fmt.Println(err) } var decodeArgs map[string]string err =json.Unmarshal(input, \u0026amp;decodeArgs) if err != nil { return } b, err := hex.DecodeString(decodeArgs[\u0026#34;a\u0026#34;]) if err != nil { return } fmt.Println(\u0026#34;b\u0026#34;, b) fmt.Println(\u0026#34;len b\u0026#34;, len(b)) // output a [230 136] len a 2 b [230 136] len b 2 服务端声明一个对应的接收struct\ngo Copy type tb struct { Bytes []byte } func test() { bt := []byte{230,136} args := tb{Bytes: bt} fmt.Printf(\u0026#34;a %v\\n\u0026#34;,bt) println(\u0026#34;len a\u0026#34;, len(bt)) input, err := json.Marshal(args) if err != nil { fmt.Println(err) } var decodeArgs tb err =json.Unmarshal(input, \u0026amp;decodeArgs) if err != nil { return } if err != nil { return } fmt.Println(\u0026#34;b\u0026#34;, decodeArgs.Bytes) fmt.Println(\u0026#34;len b\u0026#34;, len(decodeArgs.Bytes)) } // output a [230 136] len a 2 b [230 136] len b 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 type tb struct { Bytes []byte } func test() { bt := []byte{230,136} args := tb{Bytes: bt} fmt.Printf(\u0026#34;a %v\\n\u0026#34;,bt) println(\u0026#34;len a\u0026#34;, len(bt)) input, err := json.Marshal(args) if err != nil { fmt.Println(err) } var decodeArgs tb err =json.Unmarshal(input, \u0026amp;decodeArgs) if err != nil { return } if err != nil { return } fmt.Println(\u0026#34;b\u0026#34;, decodeArgs.Bytes) fmt.Println(\u0026#34;len b\u0026#34;, len(decodeArgs.Bytes)) } // output a [230 136] len a 2 b [230 136] len b 2 ","date":"2022-09-29T00:00:00Z","permalink":"https://superlitian.github.io/p/gojsonquestion/","title":"go json 序列化问题"},{"content":"Kates 基于discord + 百度智能云自动对话unit平台实现社区治理机器人。\nmian.py python Copy #!/usr/bin/env python3 import discord import re import unit intents = discord.Intents.default() intents.members = True client = discord.Client(proxy=\u0026#34;http://127.0.0.1:7890\u0026#34;, intents=intents) # discord 机器人 token token = \u0026#39;\u0026#39; @client.event async def on_ready(): print(\u0026#34;Bot client logged-in as: %s\u0026#34; % client.user) @client.event async def on_member_join(member): str = discord.Embed(title=\u0026#34;👏🏻👏🏻👏🏻👏🏻👏🏻\u0026#34;,description=f\u0026#34;Hi, {member.mention},\u0026#34; f\u0026#34; 欢迎你来到{member.guild.name}社区\u0026#34;, color=0x00ff00) # await member.create_dm() # await member.dm_channel.send(embed=str) # 频道管道 channel = client.get_channel() await channel.send(embed=str) @client.event async def on_message(message): # 排除bot自身的消息 if message.author == client.user: return # ping/pong测试，然后删除测试消息 if message.content == \u0026#39;welcome\u0026#39;: await on_member_join(message.author) # 返回at机器人的消息 elif client.user.mentioned_in(message): trim_mentioned_msg = re.sub(\u0026#34;\u0026lt;@!?(\\d\u0026#43;)\u0026gt;\u0026#34;, \u0026#34;\u0026#34;, message.content).strip() # 调用百度智能机器人 await message.channel.send( f\u0026#34;{message.author.mention} {unit.talk(trim_mentioned_msg)}\u0026#34;) # www.baidu.com if __name__ == \u0026#34;__main__\u0026#34;: unit.get_token() client.run(token) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #!/usr/bin/env python3 import discord import re import unit intents = discord.Intents.default() intents.members = True client = discord.Client(proxy=\u0026#34;http://127.0.0.1:7890\u0026#34;, intents=intents) # discord 机器人 token token = \u0026#39;\u0026#39; @client.event async def on_ready(): print(\u0026#34;Bot client logged-in as: %s\u0026#34; % client.user) @client.event async def on_member_join(member): str = discord.Embed(title=\u0026#34;👏🏻👏🏻👏🏻👏🏻👏🏻\u0026#34;,description=f\u0026#34;Hi, {member.mention},\u0026#34; f\u0026#34; 欢迎你来到{member.guild.name}社区\u0026#34;, color=0x00ff00) # await member.create_dm() # await member.dm_channel.send(embed=str) # 频道管道 channel = client.get_channel() await channel.send(embed=str) @client.event async def on_message(message): # 排除bot自身的消息 if message.author == client.user: return # ping/pong测试，然后删除测试消息 if message.content == \u0026#39;welcome\u0026#39;: await on_member_join(message.author) # 返回at机器人的消息 elif client.user.mentioned_in(message): trim_mentioned_msg = re.sub(\u0026#34;\u0026lt;@!?(\\d+)\u0026gt;\u0026#34;, \u0026#34;\u0026#34;, message.content).strip() # 调用百度智能机器人 await message.channel.send( f\u0026#34;{message.author.mention} {unit.talk(trim_mentioned_msg)}\u0026#34;) # www.baidu.com if __name__ == \u0026#34;__main__\u0026#34;: unit.get_token() client.run(token) unit.py python Copy import json import time import requests Token = \u0026#34;\u0026#34; def talk(text): url = \u0026#39;https://aip.baidubce.com/rpc/2.0/unit/service/v3/chat?access_token=\u0026#39; \u0026#43; Token request = { \u0026#39;terminal_id\u0026#39;: \u0026#39;123456\u0026#39;, \u0026#39;query\u0026#39;: text } param = { \u0026#39;version\u0026#39;: \u0026#39;3.0\u0026#39;, \u0026#39;service_id\u0026#39;: \u0026#39;S71734\u0026#39;, \u0026#39;session_id\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;log_id\u0026#39;: str(time.time()), \u0026#39;request\u0026#39;: request } headers = {\u0026#39;content-type\u0026#39;: \u0026#39;application/json\u0026#39;} response = requests.post(url, data=json.dumps(param), headers=headers) if response: print(response.json()) return response.json()[\u0026#39;result\u0026#39;][\u0026#39;context\u0026#39;][\u0026#39;SYS_PRESUMED_HIST\u0026#39;][1] else: return \u0026#34;我也不是太明白~\u0026#34; def get_token(): global Token # 百度智能云鉴权信息 ak = \u0026#39;\u0026#39; sk = \u0026#39;\u0026#39; host = f\u0026#39;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials\u0026amp;client_id={ak}\u0026amp;client_secret={sk}\u0026#39; response = requests.get(host) if response: Token = response.json()[\u0026#39;access_token\u0026#39;] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import json import time import requests Token = \u0026#34;\u0026#34; def talk(text): url = \u0026#39;https://aip.baidubce.com/rpc/2.0/unit/service/v3/chat?access_token=\u0026#39; + Token request = { \u0026#39;terminal_id\u0026#39;: \u0026#39;123456\u0026#39;, \u0026#39;query\u0026#39;: text } param = { \u0026#39;version\u0026#39;: \u0026#39;3.0\u0026#39;, \u0026#39;service_id\u0026#39;: \u0026#39;S71734\u0026#39;, \u0026#39;session_id\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;log_id\u0026#39;: str(time.time()), \u0026#39;request\u0026#39;: request } headers = {\u0026#39;content-type\u0026#39;: \u0026#39;application/json\u0026#39;} response = requests.post(url, data=json.dumps(param), headers=headers) if response: print(response.json()) return response.json()[\u0026#39;result\u0026#39;][\u0026#39;context\u0026#39;][\u0026#39;SYS_PRESUMED_HIST\u0026#39;][1] else: return \u0026#34;我也不是太明白~\u0026#34; def get_token(): global Token # 百度智能云鉴权信息 ak = \u0026#39;\u0026#39; sk = \u0026#39;\u0026#39; host = f\u0026#39;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials\u0026amp;client_id={ak}\u0026amp;client_secret={sk}\u0026#39; response = requests.get(host) if response: Token = response.json()[\u0026#39;access_token\u0026#39;] ","date":"2022-09-29T00:00:00Z","image":"https://superlitian.github.io/p/kates/kates_hu38fc63566810e7ae399e2f7c8a810aeb_244696_120x120_fill_q75_box_smart1.jpg","permalink":"https://superlitian.github.io/p/kates/","title":"Kates - discord 机器人"},{"content":"Short_content 合约设计 查询逻辑 根据 userid 查询，结果为一个集合。集合内容为完整的存证信息：标题、类别、内容。 根据 userid + title 查询，结果为一个字符串。内容为一个完整的存证信息：标题、类别、内容。标题 = title。 根据 userid + topic 查询，结果为一个集合。内容为完整的存证信息：标题、类别、内容。区别在于所有类别 = topic。 怎么设计 userid\nuserid 需要对应一个集合。对应哪个集合？\nMapping(userid =\u0026gt; ?[]) useridToContent\ntopic\ntopic 也需要对应一个集合，但是索引键为 userid + topic， 怎么设计？\nMapping(userid+topic =\u0026gt; ?[]) topics\ntitle\ntitle 不需要集合，但是表现形式应该为： userid + title = content 的所有内容。\nMapping(userid + title =\u0026gt; ?) Article\n引入一个结构体能解决这个问题吗？\nsolidity Copy // 该结构体是否要包含userid? 先不包含写一下看 struct Article{ string title; string topic; string content; } // userid 怎么与 Article 对应？ mapping(string =\u0026gt; Article[]) allArticle ? // 那么create 怎么操作？ function create(string userid, string title, string topic, string content){ Article a = Article{ title: title, topic: topic, content: conten }; allArtcile[userid].push(a); // 这样看起来没问题， userid 到 article 的映射可以解决，但是怎么查询呢？ return allArtcile[userid] ? 这样返回的是结构体数组，甚至不是stirng 数组， evm 支持吗？ // todo: 确认evm 是否支持 struct[] 返回，以及 xchain 是否支持。 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 该结构体是否要包含userid? 先不包含写一下看 struct Article{ string title; string topic; string content; } // userid 怎么与 Article 对应？ mapping(string =\u0026gt; Article[]) allArticle ? // 那么create 怎么操作？ function create(string userid, string title, string topic, string content){ Article a = Article{ title: title, topic: topic, content: conten }; allArtcile[userid].push(a); // 这样看起来没问题， userid 到 article 的映射可以解决，但是怎么查询呢？ return allArtcile[userid] ? 这样返回的是结构体数组，甚至不是stirng 数组， evm 支持吗？ // todo: 确认evm 是否支持 struct[] 返回，以及 xchain 是否支持。 } Evm 是支持这样写的，但注意要添加 pragma experimental ABIEncoderV2;\n那么此合约遇到的问题便迎刃而解，但是需要做循环匹配topic title 这些，总的来说，这个合约不是非常合理\n为了更合理的设计合约，决定用多个 mapping 来进行匹配\n合约实现 solidity Copy // SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.7.4; pragma experimental ABIEncoderV2; contract ShortContent{ // userid 对应一个集合， userid =\u0026gt; title\u0026#43;topic\u0026#43;content mapping(string =\u0026gt; string[]) userArticles; // userid \u0026#43; topic 对应一个集合 userid \u0026#43; topic =\u0026gt; title \u0026#43; topic \u0026#43; content mapping(string =\u0026gt; string[]) utopicArticles; // userid \u0026#43; title 对应一篇文章 userid \u0026#43; title =\u0026gt; title \u0026#43; topic \u0026#43; content mapping(string =\u0026gt; string) utitleArticles; // 长度限制 uint256 maxTopicLen; uint256 maxTitleLen; uint256 maxContentLen; constructor(){ maxTopicLen = 36; maxTitleLen = 100; maxContentLen = 3000; } function storeShortContent(string memory userid, string memory title, string memory topic, string memory content) external returns (string memory message) { // 长度检验 require(bytes(title).length \u0026lt; maxTitleLen, \u0026#34;this title is too long\u0026#34;); require(bytes(topic).length \u0026lt; maxTopicLen, \u0026#34;this topic is too long\u0026#34;); require(bytes(content).length \u0026lt; maxContentLen, \u0026#34;this content is too long\u0026#34;); // 添加映射 string memory result = string(abi.encodePacked(userid,\u0026#34;/\u0026#34;,title,\u0026#34;/\u0026#34;,topic,\u0026#34;/\u0026#34;,content)); string memory utopic = string(abi.encodePacked(userid,topic)); string memory utitle = string(abi.encodePacked(userid,title)); userArticles[userid].push(result); utopicArticles[utopic].push(result); utitleArticles[utitle] = result; return \u0026#34;store short content success\u0026#34;; } function queryByUser(string memory userid) public view returns(string[] memory articles){ return userArticles[userid]; } function queryByTopic(string memory userid, string memory topic) public view returns(string[] memory articles){ string memory utopic = string(abi.encodePacked(userid,topic)); return utopicArticles[utopic]; } function queryByTitle(string memory userid, string memory title) public view returns(string memory articles){ string memory utitle = string(abi.encodePacked(userid,title)); return utitleArticles[utitle]; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.7.4; pragma experimental ABIEncoderV2; contract ShortContent{ // userid 对应一个集合， userid =\u0026gt; title+topic+content mapping(string =\u0026gt; string[]) userArticles; // userid + topic 对应一个集合 userid + topic =\u0026gt; title + topic + content mapping(string =\u0026gt; string[]) utopicArticles; // userid + title 对应一篇文章 userid + title =\u0026gt; title + topic + content mapping(string =\u0026gt; string) utitleArticles; // 长度限制 uint256 maxTopicLen; uint256 maxTitleLen; uint256 maxContentLen; constructor(){ maxTopicLen = 36; maxTitleLen = 100; maxContentLen = 3000; } function storeShortContent(string memory userid, string memory title, string memory topic, string memory content) external returns (string memory message) { // 长度检验 require(bytes(title).length \u0026lt; maxTitleLen, \u0026#34;this title is too long\u0026#34;); require(bytes(topic).length \u0026lt; maxTopicLen, \u0026#34;this topic is too long\u0026#34;); require(bytes(content).length \u0026lt; maxContentLen, \u0026#34;this content is too long\u0026#34;); // 添加映射 string memory result = string(abi.encodePacked(userid,\u0026#34;/\u0026#34;,title,\u0026#34;/\u0026#34;,topic,\u0026#34;/\u0026#34;,content)); string memory utopic = string(abi.encodePacked(userid,topic)); string memory utitle = string(abi.encodePacked(userid,title)); userArticles[userid].push(result); utopicArticles[utopic].push(result); utitleArticles[utitle] = result; return \u0026#34;store short content success\u0026#34;; } function queryByUser(string memory userid) public view returns(string[] memory articles){ return userArticles[userid]; } function queryByTopic(string memory userid, string memory topic) public view returns(string[] memory articles){ string memory utopic = string(abi.encodePacked(userid,topic)); return utopicArticles[utopic]; } function queryByTitle(string memory userid, string memory title) public view returns(string memory articles){ string memory utitle = string(abi.encodePacked(userid,title)); return utitleArticles[utitle]; } } xchain测试 编译合约\nsolcjs --abi --bin ./short_content.sol -o build\n测试存储\n测试查询\n","date":"2022-09-28T00:00:00Z","image":"https://superlitian.github.io/p/shortcontent/header_hu58eb6555178a77861c10495595dbf0eb_18332_120x120_fill_q75_box_smart1.jpg","permalink":"https://superlitian.github.io/p/shortcontent/","title":"短内容存证合约"},{"content":"合约介绍 场景介绍 campaign 合约，实现场景为学生会主席竞选流程。\n流程介绍 合约初始化时，指定具有owner权限的账户，该账户具有检票与提名候选人以及启动竞选提案的权利。 启动竞选提案，需要提名一位候选人，并指定提案通过票数阈值，更新提案状态为投票中，返回该次提案ID。 任何人都可以根据提案ID查询该提案的状态。 当提案状态为投票中，任何人可以调用投票功能进行投票，限投一人一票，重复投票不会生效。 当票数大于启动提案时设置的阈值，提案状态为待检票，owner 可启动检票。 检票会进行身份验证，只有owner账户可以成功调用。 检票通过后，提案流程结束，提案状态置为已生效，此时任何人都可以查询当前学生会主席信息。 当提案状态为未启动、已生效、待检票时，不可使用投票功能。 任何人都可根据提案ID查询该提案的候选人信息。 功能介绍 constructor Params: owner: type: address desc: owner权限设置 Desc: 设置owner权限账户，初始化提案状态 propose Params: candidate: type: string desc: 候选人 target: type: uint256 desc: 票数阈值 Returns: proposalId: type: uint256 desc: 提案ID Desc: 启动竞选提案 queryProposal Params:\nproposalId: type: uint256 desc: 提案ID Returns:\nstatus: type: string desc: 提案状态：未启动(stoped)、投票中(voting)、待检票(passed)、已生效(completed) Desc: 查询提案状态\nvote Params:\nproposalId: type: uint256 desc: 提案ID Retruns:\nstatus: type: string desc: 投票状态：\u0026ldquo;success\u0026rdquo; or \u0026ldquo;error\u0026rdquo;，error需给出原因 Desc: 进行投票，调用该方法，视为调用者进行投票一次\nqueryVotes Params:\nproposalId: type: uint256 desc: 提案ID Returns:\nvotes: type: uint256 desc: 当前所获票数，当状态为未启动时，应为0 Desc: 查询已经获取的票数\ncheck Params:\nproposalId: type: uint256 desc: 提案ID Returns:\nstatus: type: string desc: 检票状态：\u0026ldquo;success\u0026rdquo; or \u0026ldquo;error\u0026rdquo;，error需给出原因 Desc: 启动检票\nqueryPresident Returns: president: type: string desc: 竞选成功的候选人 Desc: 查询学生会主席信息 queryCandidate Params: proposalId: type: uint256 desc: 提案ID Returns: candidate: type: string desc: 提案候选人信息 Desc: 查询提案候选人信息 合约设计 SafeMath 可提供。\nsolidity Copy // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.0; contract campaign{ // 为 uint256 类型使用 SafeMath 库 using SafeMath for uint256; // owner 账户 address _owner; // 学生会主席 string _president; // 提案候选人 mapping(uint256 =\u0026gt; string) _candidate; // 提案票数 mapping(uint256 =\u0026gt; uint256) _votes; // 票数阈值 uint256 _votesTarget; // 提案ID uint256 _proposalId; // 提案状态 为了减少 gas 费消耗，使用uint256类型进行状态记录，并通过mapping来提供状态映射 mapping(uint256 =\u0026gt; uint256) proposalStatus; mapping(uint256 =\u0026gt; string) pstatus; // 投票者集合 mapping(uint256 =\u0026gt; mapping(address =\u0026gt; bool)) voted; /* * 初始化函数 */ constructor(address owner){ _owner = owner; // 初始化提案状态映射 pstatus[0] = \u0026#34;stoped\u0026#34;; pstatus[1] = \u0026#34;voting\u0026#34;; pstatus[2] = \u0026#34;passed\u0026#34;; pstatus[3] = \u0026#34;completed\u0026#34;; } /* * 启动竞选提案 theSender() 方法非必须，等同于 msg.sender; */ function propose(string memory candidate, uint256 target) public returns(uint256 proposalId){ // 验证身份 require(theSender() == _owner, \u0026#34;error: No permission\u0026#34;); // 验证提案状态 require(proposalStatus[_proposalId] == 0, \u0026#34;error: The proposal is not stoped status\u0026#34;); // 设置候选人 _candidate[_proposalId] = candidate; // 设置票数阈值 _votesTarget = target; // 设置提案状态 proposalStatus[_proposalId] = 1; return _proposalId; } /* * 查询提案状态 */ function queryProposal(uint256 proposalId) public view returns(string memory status){ return pstatus[proposalStatus[proposalId]]; } /* * 投票 */ function vote(uint256 proposalId) public returns(string memory status){ // 验证提案状态 require(proposalStatus[proposalId] == 1, \u0026#34;error: The proposal is not voteable\u0026#34;); // 验证是否已投票 require(voted[proposalId][theSender()] == false, \u0026#34;error: Each person can only vote once\u0026#34;); // 增加已获取的票数 _votes[proposalId] = _votes[proposalId].add(1); // 避免重复投票 voted[proposalId][theSender()] = true; // 是否达到票数阈值 if (_votes[proposalId] \u0026gt;= _votesTarget){ proposalStatus[proposalId] = 2; } return \u0026#34;vote successfuly\u0026#34;; } /* * 查询提案获取的票数 */ function queryVotes(uint256 proposalId) public view returns(uint256 votes){ return _votes[proposalId]; } /* * 检票 */ function check(uint256 proposalId) public returns(string memory status){ // 验证提案状态 require(proposalStatus[proposalId] == 2, \u0026#34;error: The proposal is not eligible for wicket\u0026#34;); // 验证调用者身份 require(theSender() == _owner, \u0026#34;error: No permission\u0026#34;); // 修改提案状态 proposalStatus[proposalId] = 3; // 修改学生会主席信息 _president = _candidate[proposalId]; // 为下一次发起提案做准备 _proposalId = _proposalId.add(1); return \u0026#34;check successfuly, the proposal will be take effect\u0026#34;; } /* * 查询学生会主席信息 */ function queryPresident() public view returns(string memory president){ return _president; } /* * 查询提案的候选人信息 */ function queryCandidate(uint256 proposalId) public view returns(string memory candidate){ return _candidate[proposalId]; } /* * 返回此次调用者 */ function theSender() private view returns(address){ return msg.sender; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring \u0026#39;a\u0026#39; not being zero, but the // benefit is lost if \u0026#39;b\u0026#39; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c \u0026#43; a % b); // There is no case in which this doesn\u0026#39;t hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026lt;= a); uint256 c = a - b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a \u0026#43; b; require(c \u0026gt;= a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.0; contract campaign{ // 为 uint256 类型使用 SafeMath 库 using SafeMath for uint256; // owner 账户 address _owner; // 学生会主席 string _president; // 提案候选人 mapping(uint256 =\u0026gt; string) _candidate; // 提案票数 mapping(uint256 =\u0026gt; uint256) _votes; // 票数阈值 uint256 _votesTarget; // 提案ID uint256 _proposalId; // 提案状态 为了减少 gas 费消耗，使用uint256类型进行状态记录，并通过mapping来提供状态映射 mapping(uint256 =\u0026gt; uint256) proposalStatus; mapping(uint256 =\u0026gt; string) pstatus; // 投票者集合 mapping(uint256 =\u0026gt; mapping(address =\u0026gt; bool)) voted; /* * 初始化函数 */ constructor(address owner){ _owner = owner; // 初始化提案状态映射 pstatus[0] = \u0026#34;stoped\u0026#34;; pstatus[1] = \u0026#34;voting\u0026#34;; pstatus[2] = \u0026#34;passed\u0026#34;; pstatus[3] = \u0026#34;completed\u0026#34;; } /* * 启动竞选提案 theSender() 方法非必须，等同于 msg.sender; */ function propose(string memory candidate, uint256 target) public returns(uint256 proposalId){ // 验证身份 require(theSender() == _owner, \u0026#34;error: No permission\u0026#34;); // 验证提案状态 require(proposalStatus[_proposalId] == 0, \u0026#34;error: The proposal is not stoped status\u0026#34;); // 设置候选人 _candidate[_proposalId] = candidate; // 设置票数阈值 _votesTarget = target; // 设置提案状态 proposalStatus[_proposalId] = 1; return _proposalId; } /* * 查询提案状态 */ function queryProposal(uint256 proposalId) public view returns(string memory status){ return pstatus[proposalStatus[proposalId]]; } /* * 投票 */ function vote(uint256 proposalId) public returns(string memory status){ // 验证提案状态 require(proposalStatus[proposalId] == 1, \u0026#34;error: The proposal is not voteable\u0026#34;); // 验证是否已投票 require(voted[proposalId][theSender()] == false, \u0026#34;error: Each person can only vote once\u0026#34;); // 增加已获取的票数 _votes[proposalId] = _votes[proposalId].add(1); // 避免重复投票 voted[proposalId][theSender()] = true; // 是否达到票数阈值 if (_votes[proposalId] \u0026gt;= _votesTarget){ proposalStatus[proposalId] = 2; } return \u0026#34;vote successfuly\u0026#34;; } /* * 查询提案获取的票数 */ function queryVotes(uint256 proposalId) public view returns(uint256 votes){ return _votes[proposalId]; } /* * 检票 */ function check(uint256 proposalId) public returns(string memory status){ // 验证提案状态 require(proposalStatus[proposalId] == 2, \u0026#34;error: The proposal is not eligible for wicket\u0026#34;); // 验证调用者身份 require(theSender() == _owner, \u0026#34;error: No permission\u0026#34;); // 修改提案状态 proposalStatus[proposalId] = 3; // 修改学生会主席信息 _president = _candidate[proposalId]; // 为下一次发起提案做准备 _proposalId = _proposalId.add(1); return \u0026#34;check successfuly, the proposal will be take effect\u0026#34;; } /* * 查询学生会主席信息 */ function queryPresident() public view returns(string memory president){ return _president; } /* * 查询提案的候选人信息 */ function queryCandidate(uint256 proposalId) public view returns(string memory candidate){ return _candidate[proposalId]; } /* * 返回此次调用者 */ function theSender() private view returns(address){ return msg.sender; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring \u0026#39;a\u0026#39; not being zero, but the // benefit is lost if \u0026#39;b\u0026#39; is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026gt; 0); // Solidity only automatically asserts when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn\u0026#39;t hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b \u0026lt;= a); uint256 c = a - b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c \u0026gt;= a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } 合约部署 编译 solc --abi --bin ./campaign.sol -o build\n部署 通过 Java SDK 在百度超级链开放网络进行部署。\nSDK使用文档：Java SDK接入指南\n获取SDK xml Copy \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baidu.xuper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xuper-java-sdk\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baidu.xuper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xuper-java-sdk\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 部署合约 java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.AddressTrans; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); AddressTrans owner = AddressTrans.xChainToEvmAddress(account.getAddress()); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); // 开放网络工作台注册的合约账户 String contractAccount = \u0026#34;\u0026#34;; account.setContractAccount(contractAccount); try { // 合约编译文件 byte[] abi = Files.readAllBytes(Paths.get(\u0026#34;./build/campaign.abi\u0026#34;)); byte[] bin = Files.readAllBytes(Paths.get(\u0026#34;./build/campaign.bin\u0026#34;)); Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;owner\u0026#34;, owner.getAddr()); Transaction tx = client.deployEVMContract(account,bin,abi,\u0026#34;campaign\u0026#34;, params); System.out.println(tx.getContractResponse().getBodyStr()); } catch (IOException e) { e.printStackTrace(); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.AddressTrans; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); AddressTrans owner = AddressTrans.xChainToEvmAddress(account.getAddress()); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); // 开放网络工作台注册的合约账户 String contractAccount = \u0026#34;\u0026#34;; account.setContractAccount(contractAccount); try { // 合约编译文件 byte[] abi = Files.readAllBytes(Paths.get(\u0026#34;./build/campaign.abi\u0026#34;)); byte[] bin = Files.readAllBytes(Paths.get(\u0026#34;./build/campaign.bin\u0026#34;)); Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;owner\u0026#34;, owner.getAddr()); Transaction tx = client.deployEVMContract(account,bin,abi,\u0026#34;campaign\u0026#34;, params); System.out.println(tx.getContractResponse().getBodyStr()); } catch (IOException e) { e.printStackTrace(); } } } 合约调用 发起提案 java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;propose\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;candidate\u0026#34;, \u0026#34;alice\u0026#34;); params.put(\u0026#34;target\u0026#34;, \u0026#34;2\u0026#34;); Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;proposalId\u0026#34;:\u0026#34;0\u0026#34;}] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;propose\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;candidate\u0026#34;, \u0026#34;alice\u0026#34;); params.put(\u0026#34;target\u0026#34;, \u0026#34;2\u0026#34;); Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;proposalId\u0026#34;:\u0026#34;0\u0026#34;}] 查询提案状态 java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryProposal\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.queryEVMContract(account,contract, method, params); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;status\u0026#34;:\u0026#34;voting\u0026#34;}] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryProposal\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.queryEVMContract(account,contract, method, params); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;status\u0026#34;:\u0026#34;voting\u0026#34;}] 投票 java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); Account account2 = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;vote\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); // 投两票 Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account vote res: \u0026#34; \u0026#43; tx.getContractResponse().getBodyStr()); // 重复投票 Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account vote res: \u0026#34; \u0026#43; tx.getContractResponse().getBodyStr()); Transaction tx2 = client.invokeEVMContract(account2,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account2 vote res: \u0026#34; \u0026#43; tx2.getContractResponse().getBodyStr()); // 非投票状态下投票 Transaction tx2 = client.invokeEVMContract(account2,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account2 vote res: \u0026#34; \u0026#43; tx2.getContractResponse().getBodyStr()); } } // output account vote res: [{\u0026#34;status\u0026#34;:\u0026#34;vote successfuly\u0026#34;}] \u0026#39;error: Each person can only vote once\u0026#39; account2 vote res: [{\u0026#34;status\u0026#34;:\u0026#34;vote successfuly\u0026#34;}] \u0026#39;error: The proposal is not voteable\u0026#39; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); Account account2 = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;vote\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); // 投两票 Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account vote res: \u0026#34; + tx.getContractResponse().getBodyStr()); // 重复投票 Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account vote res: \u0026#34; + tx.getContractResponse().getBodyStr()); Transaction tx2 = client.invokeEVMContract(account2,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account2 vote res: \u0026#34; + tx2.getContractResponse().getBodyStr()); // 非投票状态下投票 Transaction tx2 = client.invokeEVMContract(account2,contract, method, params, BigInteger.ZERO); System.out.println(\u0026#34;account2 vote res: \u0026#34; + tx2.getContractResponse().getBodyStr()); } } // output account vote res: [{\u0026#34;status\u0026#34;:\u0026#34;vote successfuly\u0026#34;}] \u0026#39;error: Each person can only vote once\u0026#39; account2 vote res: [{\u0026#34;status\u0026#34;:\u0026#34;vote successfuly\u0026#34;}] \u0026#39;error: The proposal is not voteable\u0026#39; 查询已经获取的票数 java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryVotes\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.queryEVMContract(account,contract, method, params); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;votes\u0026#34;:\u0026#34;2\u0026#34;}] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryVotes\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.queryEVMContract(account,contract, method, params); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;votes\u0026#34;:\u0026#34;2\u0026#34;}] 检票 java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;check\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;status\u0026#34;:\u0026#34;check successfuly, the proposal will be take effect\u0026#34;}] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;check\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;status\u0026#34;:\u0026#34;check successfuly, the proposal will be take effect\u0026#34;}] 查询学生会主席信息 java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryPresident\u0026#34;; Transaction tx = client.queryEVMContract(account,contract, method, null); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;president\u0026#34;:\u0026#34;alice\u0026#34;}] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryPresident\u0026#34;; Transaction tx = client.queryEVMContract(account,contract, method, null); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;president\u0026#34;:\u0026#34;alice\u0026#34;}] 查询候选人信息 java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryCandidate\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.queryEVMContract(account,contract, method, params); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;candidate\u0026#34;:\u0026#34;alice\u0026#34;}] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;queryCandidate\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;proposalId\u0026#34;, \u0026#34;0\u0026#34;); Transaction tx = client.queryEVMContract(account,contract, method, params); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;candidate\u0026#34;:\u0026#34;alice\u0026#34;}] 创建新一轮提案 java Copy import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;propose\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;candidate\u0026#34;, \u0026#34;bob\u0026#34;); params.put(\u0026#34;target\u0026#34;, \u0026#34;3\u0026#34;); Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;proposalId\u0026#34;:\u0026#34;1\u0026#34;}] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import com.baidu.xuper.api.Account; import com.baidu.xuper.api.Transaction; import com.baidu.xuper.api.XuperClient; import com.baidu.xuper.config.Config; import java.math.BigInteger; import java.util.HashMap; import java.util.Map; public class Main { public static XuperClient client; public static void main(String[] args) { // 设置背书服务 Config.setConfigPath(\u0026#34;./conf/sdk.yaml\u0026#34;); Account account = Account.getAccountFromFile(\u0026#34;开放网络私钥目录\u0026#34;,\u0026#34;安全码\u0026#34;); client = new XuperClient(\u0026#34;39.156.69.83:37100\u0026#34;); String contract = \u0026#34;campaign\u0026#34;; String method = \u0026#34;propose\u0026#34;; Map\u0026lt;String,String\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;candidate\u0026#34;, \u0026#34;bob\u0026#34;); params.put(\u0026#34;target\u0026#34;, \u0026#34;3\u0026#34;); Transaction tx = client.invokeEVMContract(account,contract, method, params, BigInteger.ZERO); System.out.println(tx.getContractResponse().getBodyStr()); } } // output [{\u0026#34;proposalId\u0026#34;:\u0026#34;1\u0026#34;}] ","date":"2022-09-28T00:00:00Z","image":"https://superlitian.github.io/p/campaign/header_hud30b7d800d6a863e0643d87b3a87316b_148688_120x120_fill_q75_box_smart1.jpg","permalink":"https://superlitian.github.io/p/campaign/","title":"提案投票合约"}]